1
00:00:00,001 --> 00:00:04,636
[MUSIC]
［音乐］

2
00:00:04,638 --> 00:00:07,672
Stanford University.
斯坦福大学

3
00:00:13,579 --> 00:00:18,248
Okay, well welcome to Stanford CS193p, Winter of 2015.
欢迎来到2015冬季学期，斯坦福大学CS193P课程。

4
00:00:18,250 --> 00:00:20,983
This is lecture number five.
这次是第五讲。

5
00:00:20,985 --> 00:00:22,318
And, today we're gonna finish up
这次我们要继续上次没讲完

6
00:00:22,320 --> 00:00:24,486
what were talking about last time.
的内容。

7
00:00:24,488 --> 00:00:27,289
And talk a little bit about Objective-C compatibility,
然后再说一点关于Objective-C兼容性的问题。

8
00:00:27,291 --> 00:00:29,991
because, of course iOS was originally written in
因为iOS起初是用Objective-C 这种

9
00:00:29,993 --> 00:00:31,426
an entirely different language.
完全不同于Swift的语言写的。

10
00:00:31,428 --> 00:00:33,078
And so there's a little bit of
所以在旧世界和Swift的世界中间

11
00:00:33,079 --> 00:00:34,729
bridging between the Swift world and the old world.
需要有一个桥接。

12
00:00:34,731 --> 00:00:37,931
And we're gonna talk about an example of
然后我们会讲 Property List，这是适用

13
00:00:37,933 --> 00:00:41,168
using AnyObject which is Property Lists.
AnyObject的又一个例子。

14
00:00:41,170 --> 00:00:43,703
And I'm gonna do a kind of a brief demo even,
这里我会用一个简单的

15
00:00:43,705 --> 00:00:45,104
showing you that.
demo来演示这个。

16
00:00:45,106 --> 00:00:50,793
Then we're gonna move onto a completely new topic, which is views.
然后我们就要开始一个全新的课题，view

18
00:00:50,794 --> 00:00:53,645
So, views on how we draw, and how we handle touch input.
是关于在我们的UI里，如何绘制view，

19
00:00:53,647 --> 00:00:56,381
In our UI and so we're gonna go over that, and
如何响应触屏事件，先讲一些内容，然后

20
00:00:56,383 --> 00:00:58,116
I'll be having a demo for that as well.
依然会有一个demo。

21
00:00:58,118 --> 00:01:00,818
So, I'm gonna blast through these slides pretty quick.
幻灯片我可能会讲的比较快。

22
00:01:00,820 --> 00:01:04,188
As usual, the demonstration is probably
总体来说，示例会比幻灯片更

23
00:01:04,190 --> 00:01:06,823
a little more elucidating then some of the slides, cuz when
容易让你们理解，因为当你们真正看见如何做的

24
00:01:06,825 --> 00:01:08,925
you see it in action, it's a lot easier to understand.
时候，知识会容易理解的多。

25
00:01:08,927 --> 00:01:11,995
Okay.

26
00:01:11,996 --> 00:01:15,064
So, Objective-C compatibility, so, virtually all the iOS API,
下面开始讲 Objective-C 兼容的问题， 基本上iOS全部的API都是

27
00:01:15,066 --> 00:01:20,002
this API that was written over the last, however many years,
在之前许多年内用 Objective-C 写的。

28
00:01:20,004 --> 00:01:23,905
in Objective-C, is available from Swift.
现在在Swift里也可以用。

29
00:01:23,907 --> 00:01:25,773
And you can't even tell the difference, okay?
甚至你都看不出区别来。

30
00:01:25,775 --> 00:01:29,176
It's just kind of, automatically made available.
就好像非常自然的就可以用一样。

31
00:01:29,178 --> 00:01:30,711
And, when they designed Swift,
但是当他们设计Swift的时候，

32
00:01:30,713 --> 00:01:33,513
they went to a lot of trouble to make sure that it would,
为了达到非常好的兼容性，他们遇到了

33
00:01:33,515 --> 00:01:35,515
could be done in a very compatible way.
很多麻烦。

34
00:01:35,517 --> 00:01:38,785
So, that all of the iOS API, would work,
所以现在的这些 API，在Swift里

35
00:01:38,787 --> 00:01:40,553
just fine in Swift.
还算能用。

36
00:01:40,555 --> 00:01:44,523
There's few special data types though, that they've gone
但是有一些特殊的数据类型，在交接两种语言的

37
00:01:44,525 --> 00:01:49,294
to special care to bridge between the two languages,
时候需要特殊的注意。

38
00:01:49,296 --> 00:01:54,532
and this makes using iOS API from Objective-C, much easier
这使得使用 Objective-C 调用 iOS API的时候，会比Swift

39
00:01:54,534 --> 00:01:58,235
in Swift, and so, I'm gonna talk briefly about those.
容易很多，我下边会简要的说一下这个问题。

40
00:01:58,237 --> 00:02:00,203
One is NSString.
其中一个就是 NSString 。


41
00:02:00,205 --> 00:02:02,939
That is the old way that String were represented,
这是String以前的形式，

42
00:02:02,941 --> 00:02:06,775
in iOS, and that is bridged interchangeably to
在iOS里， 它与Swift的String

43
00:02:06,777 --> 00:02:07,909
Swift's String.
是可以互换使用的。

44
00:02:07,911 --> 00:02:09,310
You can't really even tell the difference.
甚至可以当它们没有区别。

45
00:02:09,312 --> 00:02:11,546
If you have a method that takes an NSString,
如果有一个方法接受 NSString 的参数，

46
00:02:11,548 --> 00:02:14,415
you can pass a Swift String in there, and vice-versa.
你可以传一个Swift的String进去，反之亦然。

47
00:02:14,417 --> 00:02:16,283
Okay, they're just automatically treated if
尽管他们两个是非常不同的东西，

48
00:02:16,285 --> 00:02:17,317
they were the same thing,
它们还是被当成

49
00:02:17,319 --> 00:02:19,119
even though they are quite different things.
完全一样的。

50
00:02:19,121 --> 00:02:22,088
String in Swift is not even a class.
Swift里的String甚至都不是一个类，

51
00:02:22,090 --> 00:02:23,189
Okay, its just a struct.
而仅仅是一个 struct 。

52
00:02:23,191 --> 00:02:26,258
So, they've done some miraculous work to
苹果的人做了非常神奇的工作把

53
00:02:26,260 --> 00:02:27,592
bridge these things.
它们桥接了起来。

54
00:02:27,594 --> 00:02:30,528
NSArray, which is the old Array,
数组的老版本， NSArray，

55
00:02:30,530 --> 00:02:33,865
is bridged to Array of AnyObject.
桥接到Swift 里就是 AnyObject 元素组成的数组。

56
00:02:33,867 --> 00:02:37,468
Okay, so any time you see, an Array of AnyObject in
所以以后只要你们在iOS的API里看到

57
00:02:37,470 --> 00:02:42,439
an iOS API, it's because it was an NSArray before, okay?
AnyObject 的数组，说明他们以前都是 NSArray 。

58
00:02:42,441 --> 00:02:44,374
Then NSDictionary is an interesting one,
NSDictionary 是比较有趣的一个，

59
00:02:44,376 --> 00:02:47,343
it's bridged to Dictionary where the keys have to be
在Swift里，它被桥接成键是 NSObject 的子类对象

60
00:02:47,345 --> 00:02:52,848
subclasses of NSObject, and the values are AnyObject, okay?
而值是 AnyObject

62
00:02:52,850 --> 00:02:55,350
Now, you might think, that's gonna be a problem, and
你们可能觉得这样会有问题，

63
00:02:55,352 --> 00:02:58,153
I'll explain why that's not in a moment.
我一会儿会解释为什么目前这样做没问题。

64
00:02:58,155 --> 00:02:59,554
And then of course, Int and
然后，Int， Float

65
00:02:59,556 --> 00:03:03,357
Float, Double, Bool, they are all bridged to NSNumber.
Double， Bool，他们都是从 NSNumber 桥接过来的。

66
00:03:03,359 --> 00:03:04,858
We talked briefly about NSNumber,
我们之前简单的讲过 NSNumber ，

67
00:03:04,860 --> 00:03:06,960
we talked about the NSNumberFormatter and all that.
我们讲了 NSNumberFormatter 还有其他东西。

68
00:03:06,962 --> 00:03:10,430
So, NSNumber was the old Objective-C object that
所以， NSNumber 是 Objective-C 里所有关于

69
00:03:10,432 --> 00:03:12,965
just meant, any kind of numeric value.
数值的对象。

70
00:03:12,967 --> 00:03:15,801
And, so anything that used to take an NSNumber, you can
所以在所有用到 NSNumber的地方，你传入一个

71
00:03:15,803 --> 00:03:19,204
pass a Double, or Float or Int in there, and it'll just work.
Double，Float 或者 Int 都是没问题的。

72
00:03:19,206 --> 00:03:21,573
Of course, coming back the other way isn't automatic,
当然反过来是不行的，

73
00:03:21,575 --> 00:03:23,775
because it doesn't really know necessarily what you want.
因为那样系统就不知道你到底需要那种数字类型了。

74
00:03:24,811 --> 00:03:27,278
But you can use the methods like doubleValue or
当然你可以用类似 doubleValue 或者

75
00:03:27,280 --> 00:03:31,382
IntValue, like we use doubleValue, in the Calculator.
IntValue 的这样的方法， 比如我们在计算器里就用了 doubleValue。

76
00:03:31,384 --> 00:03:34,484
And of course, Int and Float and Double are also bridged to
当然 Int Float 和 Double 都是和 C 语言

77
00:03:34,486 --> 00:03:37,287
the C types int, float, and double.
里的int，float 和 double 桥接好的。

78
00:03:37,289 --> 00:03:41,390
So, you have an API that takes an int, and hold a C int.
所以如果一个API里结构一个C语言的int参数，

79
00:03:41,392 --> 00:03:45,194
It'll be bridged to take capital I Swift Int.
它也可以接受一个 Swift 里的 Int （I是大写的）。

80
00:03:45,196 --> 00:03:48,296
So, this stuff, all just works completely automatically.
这个特性是完全自动生效的，

81
00:03:48,298 --> 00:03:51,232
And you don't ever have to do anything.And it just works.
我们什么都不需要做。


83
00:03:51,234 --> 00:03:55,803
However, if you wanna be explicit, about the type,
然后，如果你需要非常明确的类型，

84
00:03:55,805 --> 00:03:57,270
you can cast, okay?
你可以做类型转换。

85
00:03:57,272 --> 00:04:01,240
So, it is perfectly legal to cast a Swift String to
把 Swift 的String转换成 NSString 是完全合法的，

86
00:04:01,242 --> 00:04:04,543
an NSString, and it will always work, so
不会有任何问题，

87
00:04:04,545 --> 00:04:06,145
you don't need as?
并且不需要 as？。

88
00:04:06,147 --> 00:04:09,114
Okay, it's all a hundred percent guaranteed cast.
这是完全安全的转换。

89
00:04:09,116 --> 00:04:10,916
And then once you do that,
如果你这么做，

90
00:04:10,917 --> 00:04:12,717
you have an NSString instead of a String, and so
你就把之前的String转换成了 NSString ，

91
00:04:12,719 --> 00:04:15,620
you can send it messages that are in NSString.
你就可以给它发送 NSString 的消息了。

92
00:04:15,622 --> 00:04:17,421
Although you wanna be careful with some of them,
你们也需要注意一些问题，

93
00:04:17,423 --> 00:04:19,990
like length, is an NSString method,
比如length 是一个 NSString，

94
00:04:19,992 --> 00:04:22,325
that doesn't exist on String.
在 String 里并不存在。

95
00:04:22,327 --> 00:04:24,661
It doesn't exist on String for a reason.
它在 String 里不存在是有原因的，

96
00:04:24,663 --> 00:04:27,830
Because, we talked about this before, you know,
我们曾经讲过，

97
00:04:27,832 --> 00:04:31,066
the length of a Unicode String, can vary,
Unicode 字符串的长度是可变的，

98
00:04:32,269 --> 00:04:35,403
compared to the number of glyphs you'll see on screen,
根据你在屏幕上看到符号的不同而不同，

99
00:04:35,405 --> 00:04:37,739
and the new Swift String deals with that, and the old
新的 Swift 的 String 会处理此类字符串，但是 NSString 确实

100
00:04:37,741 --> 00:04:40,307
NSString doesn't really deal with that properly.
没有很好的处理。

101
00:04:40,309 --> 00:04:43,577
So, you gotta be careful, when you start calling NSString
所以当你要调用 NSString 方法的时候要特别小心，

102
00:04:43,579 --> 00:04:45,012
methods that, you know,

103
00:04:45,014 --> 00:04:47,614
there's not, you wanna look for a String equivalent, and
尽量用 String 代替，因为

104
00:04:47,616 --> 00:04:49,349
use that if you can, because it's newer, and
String 是最新的，

105
00:04:49,351 --> 00:04:52,284
it does thinks a little more accurately.
而且可以更精确。

106
00:04:52,286 --> 00:04:57,189
But NSArray is the same thing, you can cast from an Array,
NSArray 也是一样的， 你可以从 Swift 的 Array

107
00:04:57,191 --> 00:04:59,457
that you have in Swift, to an NSArray, and
转换到它，

108
00:04:59,459 --> 00:05:01,025
then you can call them methods in NSArray.
然后你就可以调用 NSArray 的方法了。

109
00:05:01,027 --> 00:05:03,594
Like componentsJoinedByString, which is kinda cool,
比如 componentsJoinedByString 就是一个很酷的方法，

110
00:05:03,596 --> 00:05:05,429
it takes all the components in the Array,
它收集数组中的所有元素，

111
00:05:05,431 --> 00:05:07,964
sends them description, takes those descriptions and
给它们一个描述，然后用传进来的字符串把

112
00:05:07,966 --> 00:05:10,400
joins them by the String you pass as an argument.
它们连接起来。

113
00:05:10,402 --> 00:05:14,704
This is the same as the join method in Swift's String.
这个跟Swift里String的join方法是一样的。

114
00:05:14,706 --> 00:05:17,172
Okay, so, you can look at the documentation for
你们可以去查阅 String，NSString 和 NSArray

115
00:05:17,174 --> 00:05:18,907
String and, NSString and NSArray, but
的官方文档，

116
00:05:18,909 --> 00:05:21,710
pretty much all the things you can do there, or most
基本上所有的东西，或者说大多数的东西，

117
00:05:21,712 --> 00:05:25,846
of them anyway, are available in the Swift versions.
都可以在Swift里用。

118
00:05:25,848 --> 00:05:27,281
But again, if you're passing them back and
如果你在两个版本里转换，

119
00:05:27,283 --> 00:05:30,951
forth, it's all automatic, so you'd say.
可以说都是自动的过程。

120
00:05:30,953 --> 00:05:33,753
Now, you might get a little concerned about Dictionary,
好的，你们对 Dictionary 可能还有点疑问，

121
00:05:34,989 --> 00:05:40,225
because Dictionary, the key has to be an NSObject.
因为字典的键必须是 NSObject。

122
00:05:40,227 --> 00:05:42,594
And of course, we know that String, and Array, and
当然我们知道，String，Array 和 Dictionary 在 Swift

123
00:05:42,596 --> 00:05:45,663
Dictionary in Swift, are not even objects, okay?
里都不是对象。

124
00:05:45,665 --> 00:05:47,198
They're not AnyObject, or
它们既不是 AnyObject ，

125
00:05:47,200 --> 00:05:50,401
they're, and they're not an NSObject for sure.
当然更不是 NSObject 。

126
00:05:50,403 --> 00:05:53,570
But you can still pass them anywhere you wanna pass in
但是我们依然可以在需要传 AnyObject 类型 或者 NSObject 的子类

127
00:05:53,572 --> 00:05:56,907
AnyObject, or a subclass of NSObject, because they
的参数里传入它们， 因为他们

128
00:05:56,909 --> 00:06:00,343
are bridged to classes that inherit from NSObject,
都被桥接到了 NSObject的子类里。

129
00:06:00,345 --> 00:06:01,744
because NSString, NSArray, and
因为 NSString ，NSArray 和

130
00:06:01,746 --> 00:06:03,412
NSDictionary all inherit from NSObject.
NSDictionary 全都继承自 NSObject 。

131
00:06:03,414 --> 00:06:05,814
So, that means Strings, Swift Strings,
所以 String， 也就是Swift的字符串，

132
00:06:05,816 --> 00:06:09,718
can be the keys in a Dictionary, an NSDictionary,
可以作为 NSDictionary 的键，

133
00:06:09,720 --> 00:06:11,919
even though it requires NSObject, okay?
尽管要求键是 NSObject 类型的。

134
00:06:11,921 --> 00:06:14,889
And of course, all three of them can be values,
当然，它们3个也可以作为字典的值，

135
00:06:14,891 --> 00:06:17,324
because, even though they're not really objects,
因为，尽管他们不是对象，是 struct ， 但是他们桥接

136
00:06:17,326 --> 00:06:21,994
they are structs, they are bridged to things that can be. Okay?
到 Objective-C 的东西可以作为值。


138
00:06:21,996 --> 00:06:23,529
So, it is okay to pass a String or
所以，在需要传入 AnyObject 传入

139
00:06:23,531 --> 00:06:24,530
an Array to AnyObject.
String 或者 Array 都没问题。

140
00:06:27,034 --> 00:06:30,285
You won't even notice this bridge isn't bridging 99% of the time.
你在99%的时候都见不到这种桥接，


142
00:06:30,286 --> 00:06:31,435
It just happens automatically.
它们都是自动的。

143
00:06:31,438 --> 00:06:33,637
But I just wanted you to know that's going on, so
我只是想让你们知道背后发生了什么，

144
00:06:33,639 --> 00:06:34,938
you don't get kinda confused when you start
这样在你们见到 NSString 或者 NSArray 的时候就

145
00:06:34,940 --> 00:06:37,874
seeing NSString, NSArray, what's going on, okay?
不会感到疑惑了。

146
00:06:37,876 --> 00:06:40,109
They're just being automatically bridged for you.
它们都是自动桥接过来的。

147
00:06:41,579 --> 00:06:43,396
All right.

148
00:06:43,397 --> 00:06:45,214
So, we talked about AnyObject last time,
上次我们讲过了AnyObject。

149
00:06:45,216 --> 00:06:47,182
and now I'm gonna talk about a use of AnyObject,
现在我们要讲 AnyObject 的一个用处。

150
00:06:47,184 --> 00:06:48,783
which is called Property List.
这就是 Property List 。

151
00:06:48,785 --> 00:06:51,052
So, Property List is not a type or
Property List 并不是任何一种类型，

152
00:06:51,054 --> 00:06:54,689
anything like that, it's just a term that we use.
它属于一种工具类的东西。

153
00:06:54,691 --> 00:06:58,792
And the definition of that term is, it's in AnyObject,
它的定义是，

154
00:06:58,794 --> 00:07:03,129
a Property List is AnyObject, that is known to be,
Property List 表面上是 AnyObject ， 但是在

155
00:07:03,131 --> 00:07:05,865
behind the scenes, one of those six classes.
后台，它是 NSString

156
00:07:05,867 --> 00:07:07,650
NSString, NSArray,
NSArray，

157
00:07:07,651 --> 00:07:09,434
NSDictionary, NSNumber, NSData and NSDate.
NSDictionary, NSNumber, NSData and NSDate.

158
00:07:09,437 --> 00:07:12,404
Or bridged to with Swift, okay?
这六种类型中的一种，或者是它们桥接到Swift里的版本。

159
00:07:12,406 --> 00:07:17,609
So, why do we define this Property List thing?
我们为什么要用 Property List 呢？

160
00:07:17,611 --> 00:07:19,544
It's in AnyObject.
它属于 AnyObject

161
00:07:19,545 --> 00:07:21,478
It's kind of unwieldy, because you have to do a lot,
它看起来非常笨重，因为我们需要用 is 或者 as 做

162
00:07:21,481 --> 00:07:24,115
a fair amount of casting, ising and asing, cuz
大量的类型转换，因为要使用 AnyObject，

163
00:07:24,117 --> 00:07:27,284
AnyObject, of course, to use it, we have to kinda cast it.
我们就要进行类型转换。

164
00:07:27,286 --> 00:07:30,053
And so, why do we have this thing?
所以说，我们为什么要用它？

165
00:07:30,055 --> 00:07:32,722
Two reasons really.
实际上有两个原因。

166
00:07:32,723 --> 00:07:35,390
One, Property List is used to pass data around blind.
第一， Property List 要用来隐式的传递数据。

167
00:07:35,393 --> 00:07:37,993
It's like a cookie, right? In a browser.
就好像浏览器里的cookie一样。

169
00:07:37,995 --> 00:07:40,295
It's kind of this just bundle of data,
它们是只有创建者才知道如何

170
00:07:40,297 --> 00:07:43,098
that only the creator of it knows how to interpret it,
解释它们的一组数据。

171
00:07:43,100 --> 00:07:45,166
because only they know what Strings, Arrays,
因为只有创建人才知道里边到底是 String， Array

172
00:07:45,168 --> 00:07:46,734
Dictionaries, and stuff are in there.
Dictionary 还是别的什么。

173
00:07:46,736 --> 00:07:48,252
But to everyone else it,
但是对于其他人来说

174
00:07:48,253 --> 00:07:49,769
just looks like AnyObject, so they don't know what it is.
它们就是 AnyObject ，但不知道具体是什么。

175
00:07:49,772 --> 00:07:53,273
So, all they can do, is pass it around to other things.
所以他们能做的就是把它传给其他人。

176
00:07:53,275 --> 00:07:57,010
So, it's good for blind data passing, the other thing is,
这是隐式数据传送的好处。另一个原因是

177
00:07:57,012 --> 00:08:00,580
a Property List can be used as generic data structures, okay?
Property List 可以用于泛型的数据结构。

178
00:08:00,582 --> 00:08:02,014
Since it's got Arrays, and
因为它可以是Array，

179
00:08:02,016 --> 00:08:05,584
Dictionaries, and Numbers, and Dates, and all that in there.
Dictionary， Number， Date，都有可能。

180
00:08:05,586 --> 00:08:10,021
You can turn a data structure, like your r-ops stack,
你可以把一个数据结构变成一个泛型的数据结构，就像你的

181
00:08:10,023 --> 00:08:12,523
in the CalculatorBrain, it has op enums in there,
CalculatorBrain类里面的opStack，

182
00:08:12,525 --> 00:08:14,392
that's not a generic data structure, but
它有一个叫做op的枚举，它不是泛型的

183
00:08:14,394 --> 00:08:17,461
we can turn it into a generic data structure, for example,
但是我们可以把它改成泛型的。

184
00:08:17,463 --> 00:08:20,831
and then do things with it like write it out to disk, or
泛型的数据结构可以用来写入磁盘，

185
00:08:20,833 --> 00:08:23,700
send it over the network, or things like that.
或者通过网络传送。

186
00:08:23,702 --> 00:08:26,569
So, those are the two main reasons we use Property List.
以上就是使用Property List的两个主要原因。

187
00:08:26,571 --> 00:08:31,073
And, a really good use of Property List in
Property List 在 iOS里另外一个很好的用处

188
00:08:31,075 --> 00:08:33,575
iOS is NSUserDefaults.
就是 NSUserDefaults。

189
00:08:33,577 --> 00:08:37,012
So, NSUserDefaults is like a really tiny little database,
NSUserDefaults 就像一个微型的数据库。

190
00:08:37,014 --> 00:08:39,347
and it only knows how to store Property Lists.
它只会存储Property List

191
00:08:39,349 --> 00:08:40,999
Okay?

192
00:08:41,000 --> 00:08:42,650
And it's really for things like settings, and
存储那些诸如设置，

193
00:08:42,652 --> 00:08:44,051
preferences, stuff like that.
参数等等的东西。

194
00:08:44,053 --> 00:08:45,852
You would never, it's not high performance,
由于它的性能不高，

195
00:08:45,854 --> 00:08:48,054
you would never use it for big things like images or
所以千万不要用它存一些图片什么的比较大的数据，

196
00:08:48,056 --> 00:08:50,089
anything like that, just Property Lists, you know,
只用来存 Property List，你懂的

197
00:08:50,091 --> 00:08:54,060
Dates and Strings and Doubles, and things like that.
日期，字符串，数字什么的。

198
00:08:54,062 --> 00:08:57,796
It can store and retrieve any Property List, and
它可以像字典一样存储和

199
00:08:57,798 --> 00:08:59,831
it just stores it like a Dictionary,
导出Property List，

200
00:08:59,833 --> 00:09:03,034
as if the NSUserDefaults thing itself is a Dictionary.
NSUserDefaults本身就是一个字典。

201
00:09:03,036 --> 00:09:05,103
And, it can store the whole Property List,
它可以存储所有的Property List。

202
00:09:05,105 --> 00:09:08,005
like setObject forkey: , that first method you see there.
比如 setObject forkey:， 就是你们在那看到的第一个方法。

203
00:09:08,007 --> 00:09:10,007
And, repeat, retrieve all Property List,
然后，重复，取回所有的Property List。

204
00:09:10,009 --> 00:09:12,642
or, it can just do little tiny pieces of Property List,
或者，它可以只处理Property List中的一小部分。

205
00:09:12,644 --> 00:09:14,377
like it has a method set Double,
比如，它有个方法 set Double，

206
00:09:14,379 --> 00:09:16,813
that will just set a Double for a certain key.
这将为某一 key 设置一个 Double 值。

207
00:09:16,815 --> 00:09:18,348
Okay? So,
所以，

208
00:09:18,349 --> 00:09:19,882
it's like a Dictionary in it's key value, but
它像一个有 key value 的字典，但

209
00:09:19,884 --> 00:09:21,350
it only stores Property List.
它只存储Property List。

210
00:09:21,352 --> 00:09:23,919
And, the big thing about the way it stores them,
最大的不同是，它存储这些属性，

211
00:09:23,921 --> 00:09:28,056
is that it persists when your app is gone, okay?
当你的app关闭时，它永久保存这些数据。

212
00:09:28,058 --> 00:09:29,390
So, you know,
你们知道的，

213
00:09:29,392 --> 00:09:30,958
normally, a Dictionary is stored in the heap.
一般的，一个字典存储在堆中。

214
00:09:30,960 --> 00:09:32,759
As soon as your app quits, it's gone.
只要你的 app 退出了，它就没了。

215
00:09:32,761 --> 00:09:34,327
But this, stays around, so
但这个，保留着，所以

216
00:09:34,329 --> 00:09:35,995
that when your app launches the next time,
当你的 app 在下次启动时，

217
00:09:35,997 --> 00:09:37,697
all the data's still there.
所有的数据都在。

218
00:09:37,699 --> 00:09:39,465
So, that's why it's kind of like a database, but
因此，这就是为什么它像个数据库，但

219
00:09:39,467 --> 00:09:40,932
it's very small, okay?
它非常小。

220
00:09:40,934 --> 00:09:43,034
For preference and settings.
为了性能和设置，

221
00:09:43,036 --> 00:09:45,503
Here's how you use NSUserDefaults.
这是你要怎么使用 NSUserDefaults。

222
00:09:45,505 --> 00:09:49,006
You use this type method in NSUserDefaults called
你在 NSUserDefaults 中使用这类方法

223
00:09:49,008 --> 00:09:50,974
standardUserDefaults.
standardUserDefaults。

224
00:09:50,976 --> 00:09:53,243
This gives you an instance of an NSUserDefaults.
这给你一个 NSUserDefaults 的实例。

225
00:09:53,245 --> 00:09:54,310
You're always gonna use
你总是使用同一个实例，

226
00:09:54,312 --> 00:09:56,579
the same instances like a shared instance.
类似于一个共享实例。

227
00:09:56,581 --> 00:09:58,114
You'll always to use the same one.
你总是使用同一个（实例）。

228
00:09:58,116 --> 00:10:02,117
And then you just send it messages like, you know,
然后，你就发消息给它，比如，正如你知道的，

229
00:10:02,119 --> 00:10:05,587
setObject forkey:, store this Property List, and
setObject forkey:，保存这个Property List。

230
00:10:05,589 --> 00:10:07,989
getObject forkey: to get it back.
然后使用 getObject forkey:，获取它。

231
00:10:07,991 --> 00:10:09,257
Now, the changes you make in there,
现在，你在那里做的改变，

232
00:10:09,259 --> 00:10:12,193
are automatically saved, but, there is a method called
会自动保存。有一个方法叫

233
00:10:12,195 --> 00:10:15,929
synchronize, which is kinda like save, which can force it,
synchronize，类似于 save，这个方法可以强制

234
00:10:15,931 --> 00:10:17,931
to save out to disc.
保存数据到磁盘。

235
00:10:17,933 --> 00:10:19,666
Why do you ever need synchronize when it
既然有自动保存，为什么你还需要

236
00:10:19,668 --> 00:10:21,868
auto saves?
synchronize？

237
00:10:21,869 --> 00:10:24,069
Well, in auto save, when things happen like you app
好吧，在自动保存中，当有些事情发生时，比如你的 app

238
00:10:24,072 --> 00:10:28,073
stops being the front most app,
不再作为最前端的 app，

239
00:10:28,075 --> 00:10:29,708
the user switched to another app.
用户转向使用其他 app。

240
00:10:29,710 --> 00:10:31,709
So, your app is still there, but
因此，你的 app 还在那里运行，但是

241
00:10:31,711 --> 00:10:33,077
it switched to the background.
变成后台运行了。

242
00:10:33,079 --> 00:10:35,145
It'll save then.
那时它将保存数据。

243
00:10:35,147 --> 00:10:36,580
So, it won't always save when you want, and
因此，它不会总是在你需要的时候保存数据，

244
00:10:36,582 --> 00:10:39,315
especially when you're debugging, okay?
特别是当你调试的时候。

245
00:10:39,317 --> 00:10:42,118
When you hit stop in the debugger,
当你在调试器中停止时，

246
00:10:42,120 --> 00:10:43,986
it doesn't save, okay?
它并不保存数据。

247
00:10:43,988 --> 00:10:47,289
And so, you probably wanna throw some synchronizes in
因此，你可能要放一些 synchronize，

248
00:10:47,291 --> 00:10:49,157
there, to save this thing out,
以便把数据保存下来。

249
00:10:49,159 --> 00:10:50,792
especially when you're debugging.
特别是当你调试的时候。

250
00:10:50,794 --> 00:10:52,960
It's not really that expensive to synchronize,
synchronize 操作，代价并不高，

251
00:10:52,962 --> 00:10:54,562
especially if there's not much data in there,
特别是它没有很多数据的时候。

252
00:10:54,564 --> 00:10:56,697
which there shouldn't be, because it's small.
它也不应该有很多数据，因为它很小。

253
00:10:56,699 --> 00:10:59,266
So, it can't hurt too much to throw them in there.
因此，使用 synchronize 方法并没有太大伤害。

254
00:10:59,268 --> 00:11:01,334
Okay?

255
00:11:01,336 --> 00:11:03,403
And yeah, synchronize return to Bool,
当然，synchronize 返回 Bool 值，

256
00:11:03,405 --> 00:11:05,021
whether it failed or not.
表示它失败与否。

257
00:11:05,022 --> 00:11:06,638
But if it failed, there's really not much you can do.
但如果它失败了，你也不能做太多事情，

258
00:11:07,775 --> 00:11:10,075
So, a lot of times people don't even look at the return
因此，大多数时候人们甚至不检查 synchronize 的

259
00:11:10,077 --> 00:11:13,044
values synchronize, they just synchronize, and they pray.
返回值，他们只是使用 synchronize，然后他们祈祷。

260
00:11:13,046 --> 00:11:16,014
But, it's only not gonna save if like the disk is full or
但是，它只是在磁盘满了或者其他时候无法保存数据，

261
00:11:16,016 --> 00:11:17,715
something, that virtually never happens.
但这些情况很少发生。

262
00:11:19,285 --> 00:11:20,851
All right, so, I'm gonna do a little demo here.
我要做些 demo。

263
00:11:20,853 --> 00:11:23,086
And show you a little more about Property List.
给你展示更多的 Property List。

264
00:11:23,088 --> 00:11:24,821
And also AnyObject,
还有 AnyObject。

265
00:11:24,822 --> 00:11:26,555
cuz you've never seen AnyObject in action.
你永远不会在 action 中看到 AnyObject。

266
00:11:26,558 --> 00:11:31,260
And what we're gonna do, is add a property to our
我们将做的，是在我们的 CalculatorBrain

267
00:11:31,262 --> 00:11:34,796
CalculatorBrain, which gets its program.
添加一个属性，这个属性获取它的 program。

268
00:11:35,732 --> 00:11:37,448
Okay?

269
00:11:37,449 --> 00:11:39,165
So, our CalculatorBrain has a program, especially your
所以我们的 CalculatorBrain 有一个 program，特别是你们的

270
00:11:39,168 --> 00:11:41,468
versions, where you added variables to it.
版本，当你们在其中添加变量。

271
00:11:41,470 --> 00:11:42,936
It's got this kind of program,
它会有这样的 program，

272
00:11:42,938 --> 00:11:44,337
it's almost like a little computer program.
它几乎像一个小的计算机程序。

273
00:11:44,339 --> 00:11:48,007
You can execute that program, set its variables, it's great.
你可以执行这个程序，设置变量，这很好。

274
00:11:48,009 --> 00:11:49,709
So, it would be nice if we could get that program.
如果我们能得到这个 program 会很棒。

275
00:11:49,711 --> 00:11:52,678
But we don't wanna reveal our internal data structure, and
但我们并不想暴露我们内部的数据结构，

276
00:11:52,680 --> 00:11:55,113
there's nothing anyone can do with that program.
这样任何人就不能在这个 program 上做任何事。

277
00:11:55,115 --> 00:11:56,848
So, we're really just getting it as a cookie.
实际上我们的做法是像一个 cookie 一样来获取它。

278
00:11:56,850 --> 00:11:59,717
And the only thing you can do with it, is give it back
你能做的唯一事情，把它返回给

279
00:11:59,719 --> 00:12:02,520
to the CalculatorBrain, or another CalculatorBrain in
CalculatorBrain，或者将来的其他 CalculatorBrain，

280
00:12:02,522 --> 00:12:05,389
the future, and then say, evaluate.
然后，调用 evaluate()

281
00:12:05,391 --> 00:12:07,724
Okay, so you see the value of having this?
你们看到这样做的价值没？

282
00:12:07,726 --> 00:12:09,359
So, basically getting the program out of
基本上就是，从 CalculatorBrain 中获取 program，

283
00:12:09,361 --> 00:12:10,793
the CalculatorBrain and send it back.
然后把它送回去。

284
00:12:10,795 --> 00:12:13,162
But we're gonna return it as a Property List.
但我们将以 Property List 的形式返回。

285
00:12:13,164 --> 00:12:14,196
It's gonna be AnyObject.
它会是 AnyObject。

286
00:12:14,198 --> 00:12:16,031
People are gonna look at this var, and
人们将查看这个变量，

287
00:12:16,033 --> 00:12:17,632
it's gonna be of type AnyObject, and
它会是 AnyObject 类型，

288
00:12:17,634 --> 00:12:20,068
all they can do is get it, and then set it back.
他们能做的是 get 它，然后 set 回去。

289
00:12:20,070 --> 00:12:21,503
Okay?

290
00:12:21,504 --> 00:12:22,937
So, what would that look like?
这会是什么样的？

291
00:12:22,939 --> 00:12:24,538
Let's go over here to our Calculator.
让我们到我们的 Calculator 里来。

292
00:12:24,540 --> 00:12:26,840
So, I've gone much bigger font here.
我已经在这里调了更大的字体。

293
00:12:26,842 --> 00:12:28,308
Hopefully everybody, is this big enough?
希望每个人（能看到），这个够大吗？

294
00:12:28,310 --> 00:12:30,143
Yeah?

295
00:12:30,145 --> 00:12:31,510
Okay.

296
00:12:31,512 --> 00:12:32,745
All right.

297
00:12:32,747 --> 00:12:35,514
So, this is Calculator as I last left it.
这个是我上次留下的 Calculator。

298
00:12:35,516 --> 00:12:37,716
It doesn't have your enhancements to it for
它没有你们为变量的改进。

299
00:12:37,718 --> 00:12:39,951
the variables.

300
00:12:39,953 --> 00:12:42,319
And I'm just gonna add a var here.
我就要再这里加一个 var。

301
00:12:42,321 --> 00:12:43,887
A public var.
一个 public 的 var。

302
00:12:43,889 --> 00:12:44,554
Okay?

303
00:12:44,556 --> 00:12:45,922
Called program, and
叫做 program，

304
00:12:45,924 --> 00:12:49,225
it's gonna be type AnyObject, but I'm gonna put comment here
这个会是 AnyObject 类型，但我要在这注释下，

305
00:12:49,227 --> 00:12:53,595
that says guaranteed to be a Property List.
要保证是个 Property List。

306
00:12:53,597 --> 00:12:56,965
So, the callers know that this is a Property List.
这样调用者知道这是个 Property List。

307
00:12:56,967 --> 00:13:01,002
So, for example, they could put it into NSUserDefaults.
例如，他们可以把它放入 NSUserDefaults。

308
00:13:01,004 --> 00:13:02,737
Or they could write it out to disc.
或者他们可以将这个写入磁盘。

309
00:13:02,739 --> 00:13:04,571
I haven't taught you how to write it out to disc, but
我还没教你们怎么把这个写入磁盘。

310
00:13:04,573 --> 00:13:05,706
you can do it.
你们能够做的。

311
00:13:05,708 --> 00:13:06,673
So, they could do that with it,
他们可以那样做。

312
00:13:06,675 --> 00:13:09,375
cuz they know it's a Property List, okay?
他们知道它是个 Property List。

313
00:13:09,377 --> 00:13:13,346
So, this is going to be a computed property.
这是个 computed property。

314
00:13:13,348 --> 00:13:15,948
Okay, so we're gonna have a get and a set.
我们将有一个 get 和一个 set。

315
00:13:15,950 --> 00:13:17,183
And when the get,
当 get 时，

316
00:13:17,184 --> 00:13:18,417
we're just gonna get some sort of Property
我们将获取代表我们内部数据结构的某个

317
00:13:18,419 --> 00:13:21,186
List representation of our internal data structure.
Property List。

318
00:13:21,188 --> 00:13:23,521
And when you set, we're gonna take that Property List and
当你 set 时，我们将得到 Property List 并且

319
00:13:23,523 --> 00:13:27,057
turn it back into our private representation.
把它放回我们的私有代表。

320
00:13:28,060 --> 00:13:29,259
So, the get,
这个 get，

321
00:13:30,362 --> 00:13:34,063
how are we gonna represent ourselves as a Property List
这是我们怎么将我们自己表现为一个 Property List，

322
00:13:34,065 --> 00:13:36,732
because this is really our internal data structure here,
因为这实际上是我们内部数据结构，

323
00:13:36,734 --> 00:13:39,801
it's Array of op, op is an enum,
是个 op 数组，op 是枚举类型，

324
00:13:39,803 --> 00:13:43,871
clearly enums are not NSDates, or NSStrings, or NSArrays.
显然，枚举不是 NSDates，也不是 NSStrings 或 NSArrays。

325
00:13:43,873 --> 00:13:46,407
So, we can't just return this thing, okay?
我们不能只是返回这个东西，

326
00:13:46,409 --> 00:13:48,208
Cuz that's not a Property List.
因为它不是一个 Property List。

327
00:13:48,210 --> 00:13:51,244
So, we need to return some sort of Property List.
我们必须返回某种 Property List。

328
00:13:51,246 --> 00:13:53,980
And I'm gonna return an Array of Strings.
我将返回一个 String 数组。

329
00:13:53,982 --> 00:13:58,084
And the String is either gonna be the symbol of an op,
这个 String 是某个 op 的符号，

330
00:13:58,086 --> 00:14:01,587
in which case I will look it up in knownOps, or
这个 op 我可以在 knownOps 中找到，或者

331
00:14:01,589 --> 00:14:04,956
the String will be an numeric representation of
这个 String 会是个数字字符串，代表

332
00:14:04,958 --> 00:14:06,958
the String of the operand rather.
操作数。

333
00:14:06,960 --> 00:14:08,026
Right? The Double will
对吧，Double 将转换成

334
00:14:08,028 --> 00:14:09,326
turn into a String.
一个 String。

335
00:14:09,328 --> 00:14:13,163
Which I happened to have a var that does exactly that.
刚好我有一个变量正好可以处理这个。

336
00:14:13,165 --> 00:14:15,565
Okay? This turns an enum op,
这将一个 op 枚举变成

337
00:14:15,567 --> 00:14:17,800
into a String.
一个 String。

338
00:14:17,802 --> 00:14:19,635
And I know how to turn it back.
我知道怎么把它变回来。

339
00:14:19,637 --> 00:14:22,771
Because I know how to use a number formatter to turn
因为我知道怎么使用一个 number formatter 来把一个

340
00:14:22,773 --> 00:14:25,273
the String of a operand back into a Double and
操作数字符串变成一个 Double。

341
00:14:25,275 --> 00:14:27,709
obviously I know how to look up binary and
显然我也知道怎么在 knownOps 中

342
00:14:27,711 --> 00:14:30,645
uniary operations in our knownOps.
查找二元和一元操作符。

343
00:14:30,647 --> 00:14:32,764
Okay?

344
00:14:32,765 --> 00:14:34,882
So, we could say something along these lines.
我们可以在这几行里写一些东西

345
00:14:34,884 --> 00:14:39,586
Our get, I'm gonna show you a much better get in a second,
我们的 get，我马上给你演示一个更好的 get，

346
00:14:39,588 --> 00:14:43,590
but one way we could do our get is we could just say,
实现 get 的一种方式是：

347
00:14:43,592 --> 00:14:47,226
we could make a returnValue that is going to be
定义一个 returnValue，它的类型是

348
00:14:47,228 --> 00:14:48,861
an Array of String.
Array<String>

349
00:14:48,863 --> 00:14:52,764
Okay, in fact let's just create an empty Array of
实际上，我们只是创建一个空的字符串数组，

350
00:14:52,766 --> 00:14:56,768
String here, and then we can just go through our ops,
然后我们可以在我们的 opStack 中遍历我们的操作符，

351
00:14:56,770 --> 00:14:59,737
in our opStack here, and for each op,
对于每一个操作符，

352
00:14:59,739 --> 00:15:04,307
we can just say returnValue.append, an op's description.
我们可以使用 returnValue.append，将一个操作符的描述

353
00:15:04,309 --> 00:15:07,877
On to the end of it, and then we could return, returnValue.
附加在它（returnValue）的后面，然后我们可以返回 returnValue。

354
00:15:10,748 --> 00:15:13,882
Right, makes sense, I just my internal data structure into
懂了吗？我刚刚把我的内部数据结构转变成一个

355
00:15:13,884 --> 00:15:16,918
a Property List, because this is a Property List.
Property List，因为这是一个 Property List。

356
00:15:16,920 --> 00:15:20,588
Notice I can return, this through AnyObject,
注意我可以通过 AnyObject 返回。

357
00:15:20,590 --> 00:15:22,557
because Arrays are bridged, and
因为 Arrays 是桥接好的，

358
00:15:22,559 --> 00:15:24,392
NSArray which happens to be an object.
NSArray 恰好是一个 object，

359
00:15:24,394 --> 00:15:25,392
Okay.

360
00:15:25,394 --> 00:15:27,961
But this is an awful lot of code for this.
但这里这么多行代码，太可怕了。

361
00:15:27,963 --> 00:15:31,731
We can actually do this in one line of code, okay?
实际上，我们可以仅使用一行代码

362
00:15:31,733 --> 00:15:34,834
So if you paid attention in my last lecture, you'll remember
如果你们注意我上次讲的课，你们就会记得

363
00:15:34,836 --> 00:15:36,969
that I told you about this function called map.
我跟你们说过，这个叫做 map 的函数。

364
00:15:36,971 --> 00:15:43,041
And I can actually just return my opStack mapped,
实际上我可以直接返回 opStack.map

365
00:15:43,043 --> 00:15:49,047
so that each element description is returned.
这样每个元素的描述都返回了。

366
00:15:49,049 --> 00:15:51,349
So I don't need any of this, okay?
因此我不需要这里的任何一行代码。

367
00:15:52,485 --> 00:15:54,785
So everyone understand this line of code right here?
每个人都理解了这行代码了吧。

368
00:15:54,787 --> 00:15:57,921
This is just a little closure that gets the opportunity to
这仅仅是一个闭包，它转化 opStack 内的

369
00:15:57,923 --> 00:16:00,723
convert every single thing inside opStack,
每个单一的东西，

370
00:16:00,725 --> 00:16:03,893
which is an op, these are ops, into a String and it takes
也就是将操作符，这些都是操作符，转换成字符串，

371
00:16:03,895 --> 00:16:07,396
this String and maps them all and returns a new Array.
然后得到这个字符串，然后将它们所有都映射，最后返回一个新的数组。

372
00:16:09,132 --> 00:16:09,697
Okay?

373
00:16:10,733 --> 00:16:13,434
So when you start getting familiar with Swift and
当你们开始熟悉 Swift，

374
00:16:13,436 --> 00:16:14,785
what it can do,
和 Swift 能做的事情。

375
00:16:14,786 --> 00:16:16,135
you'll start realizing a lot of things that take five or
你就开始意识到很多需要五六行代码处理的东西，

376
00:16:16,138 --> 00:16:17,570
six line of code, you can just do them in one.
现在你只需要一行。

377
00:16:18,640 --> 00:16:20,873
Okay, but it does take some experience.
但这需要一定的经验。

378
00:16:20,875 --> 00:16:22,775
So now let's talk about going the other way.
现在让我们谈谈其他方式，

379
00:16:22,777 --> 00:16:25,177
So now we have, someone gives us back our program.
现在有人给我们返回 program，

380
00:16:25,179 --> 00:16:27,245
We wanna load our opStack back up.
我们想加载上我们的 opStack，

381
00:16:27,247 --> 00:16:33,117
Well the first thing we wanna make sure is that the thing
第一件我们需要确认的事情是

382
00:16:33,119 --> 00:16:37,387
they're giving us back is an Array of these symbols.
他们给我们的是这些符号的数组。

383
00:16:37,389 --> 00:16:38,988
Because they could just give me junk,
因为他们可能给我们没用的东西。

384
00:16:38,990 --> 00:16:40,923
because it's AnyObject they could set it to anything.
这是个 AnyObject，他们可以给它设置任何值。

385
00:16:40,925 --> 00:16:42,291
So, I, I want to make sure that's what it is.
我需要确认这是什么。

386
00:16:42,293 --> 00:16:43,826
So what I'm going to do,
我将要做的是，

387
00:16:43,828 --> 00:16:47,529
I'm going to let opSymbols equal newValue, right?
输入 opSymobls = newValue，

388
00:16:47,531 --> 00:16:49,731
newValue remember we are in the setter here.
newValue 记得我们在 setter 里。

389
00:16:49,733 --> 00:16:52,633
So, newValue is the newValue which is in AnyObject.
这个 newValue 是 AnyObject 的。

390
00:16:54,070 --> 00:16:57,571
As an Array of String, because that's what it has to be.
as Array<String>，因为它必须是一个 Array<String> 才行。

391
00:16:57,573 --> 00:17:00,573
If this thing that they passed in is not an Array of String,
如果他们传递的不是字符串数组，

392
00:17:00,575 --> 00:17:02,308
I don't know what to do with it.
我就不知道怎么处理。

393
00:17:02,310 --> 00:17:07,479
So really here what I wanna do is, if let as question mark,
所以这里我想做的是， if let as?

394
00:17:07,481 --> 00:17:09,981
because they could pass me anything.
因为他们可能传给我任何东西，

395
00:17:09,983 --> 00:17:13,485
And so, here I'm using the as to make sure this AnyObject
所以这里我使用 as 以确保他们传递过来的 AnyObject

396
00:17:13,487 --> 00:17:17,488
they pass me is actually and Array of Strings, okay?
确实是个字符串数组。

397
00:17:17,490 --> 00:17:19,390
If it is, now I can convert back, so
如果是，我就可以转化回来，

398
00:17:19,392 --> 00:17:22,893
I'm gonna create something called my newOpStack which
我将创建一个 newOpStack，

399
00:17:22,895 --> 00:17:27,497
is just gonna be an Array of ops and I'm just gonna go for
它是一个操作符数组。我将遍历这个

400
00:17:27,499 --> 00:17:31,834
each opSymbol in this opSymbols.
opSymbols 里的每个 opSymbol。

401
00:17:32,836 --> 00:17:35,603
opSymbols is this thing right here, that's the Array,
opSymbols 是这个东西，这是 Array

402
00:17:35,605 --> 00:17:38,373
that's the newValue, the AnyObject converted
这是 newValue，AnyObject 转换成了

403
00:17:38,375 --> 00:17:42,776
into an Array of Strings, okay?
Array<String> 类型，明白了吗？

404
00:17:42,778 --> 00:17:48,448
So for each one if I can find a known op,
所以对于每一个 opSymbol

405
00:17:48,450 --> 00:17:53,586
that matches that symbol then this must be an op,
在 knownOps 中找到对应的 op

406
00:17:53,588 --> 00:17:56,255
and so I will just add that op
那么我就可以将

407
00:17:56,257 --> 00:18:01,326
to, to my stack, otherwise I'm gonna see
那个 op 加至我的 newOpStack 中

408
00:18:01,328 --> 00:18:04,162
if I could turn that String into an operand, and I'm gonna
否则我将尝试把字符串转换成一个操作数

409
00:18:04,164 --> 00:18:09,166
do that with if let operand equal NSNumberFormatter.
这里我可以输入 if let operand = NSNumberFormatter()

410
00:18:09,168 --> 00:18:12,736
Okay, numberFromString, I'm gonna pass it
NSNumberFormatter().numberFromString(...)

411
00:18:12,738 --> 00:18:16,773
this opSymbol that I got out of that Array it gave me.
括号里的参数我将把 opSymbol 传进去

412
00:18:16,775 --> 00:18:20,042
I'm going to use Optional Chaining here and
这里我将使用 Optional Chaining 并且

413
00:18:20,044 --> 00:18:24,113
put a question mark, then doubleValue, okay.
放一个问号在这里，然后 .doubleValue

414
00:18:24,115 --> 00:18:27,616
Remember Optional Chaining, if you have an expression like
记住，Optional Chaining 就是，如果你有一个像这样的表达式

415
00:18:27,618 --> 00:18:31,653
this, this whole expression, and if anything along the way
那么整个表达式中任意一个

416
00:18:31,655 --> 00:18:36,157
returns nil then this whole expression will return nil.
返回了 nil 的话，那么整个表达式将返回 nil

417
00:18:36,159 --> 00:18:38,659
If you put a question mark after that term.
我在这里放置了一个问号

418
00:18:38,661 --> 00:18:40,927
So, numberFromString can return nil if this is
那么如果给 numberFromString 传一个不能被解释成一个数字的 String

419
00:18:40,929 --> 00:18:44,364
not a String, that can be interpreted as a number.
它就会返回 nil

420
00:18:44,366 --> 00:18:47,000
So by putting a question mark here it says, okay?
所以这里我放置一个问号的意思是

421
00:18:47,002 --> 00:18:50,169
If that's nil than just return nil back to here.
如果这个表达式返回 nil，则 operand 也将是 nil

422
00:18:50,171 --> 00:18:52,604
Otherwise keep going and send it doubleValue.
如果不返回 nil，那么 operand 设置成表达式返回值的 doubleValue

423
00:18:53,574 --> 00:18:57,709
So this operand is either going to not get set,
这个 operand 要么不被设值

424
00:18:57,711 --> 00:19:01,879
because of the if let, or it's going to be a Double,
因为有 if let 的存在，要么它将成为一个 Double

425
00:19:01,881 --> 00:19:03,580
which is what this doubleValue comes out of here.
也就是这里出现 doubleValue 的原因

426
00:19:04,883 --> 00:19:07,384
Okay, so that's kind of explaining from last week how
好的，这就是上周我们讲的

427
00:19:07,386 --> 00:19:09,252
we did this number formatter thing.
使用 number formatter 的知识

428
00:19:09,254 --> 00:19:12,005
So in this case,
在这里

429
00:19:12,006 --> 00:19:14,757
I can just append onto the end of it that a new op.
我只需要追加一个新的 op

430
00:19:14,759 --> 00:19:19,361
So, we'll say dot operand with that operand.
我们输入 .Operand(operand)

431
00:19:19,363 --> 00:19:20,795
So we're just putting a new op on there.
这样我们就追加了一个新的 op

432
00:19:20,797 --> 00:19:24,565
So now I've built a new opStack using all those Strings,
现在我使用了所有的那些字符串创建了一个 newOpStack

433
00:19:24,567 --> 00:19:27,901
and I can just return that new opStack.
这里我将返回这个 newOpStack

434
00:19:27,903 --> 00:19:30,170
Not return it, sorry.
喔，这里不是返回

435
00:19:30,171 --> 00:19:32,438
I'm gonna set my opStack equal to that new op
而是将 opStack = newOpStack

436
00:19:32,441 --> 00:19:33,740
Stack, okay?
明白了吗？

437
00:19:33,742 --> 00:19:35,174
That's it.
就这些

438
00:19:37,111 --> 00:19:38,276
Any questions about that?
对此有什么疑问吗？

439
00:19:38,278 --> 00:19:41,513
>>Property List?
- [学生提问]

440
00:19:41,515 --> 00:19:42,780
Like that's just because.
- [学生提问]

441
00:19:42,782 --> 00:19:44,932
>> This is documentation,
这是文档

442
00:19:44,933 --> 00:19:47,083
this is a public thing, it's not private, and I'm just
这是一个 public 的东西，不是 private 的

443
00:19:47,086 --> 00:19:49,520
documenting to anyone who's using it that this is true.
这是提供给任何使用我代码的人的文档

444
00:19:49,522 --> 00:19:52,389
I can document this even better using a typealias.
我能够用 typealias 更好地整理我的代码文档

445
00:19:52,391 --> 00:19:54,290
So you can basically have a typealias,
你仅仅需要输入 typealias

446
00:19:54,292 --> 00:19:55,892
which is an alias for a type.
typealias 是一个类型的替身

447
00:19:55,894 --> 00:19:58,094
It's just a way of another type, and
是其他类型的一个替身

448
00:19:58,096 --> 00:20:00,429
I could have a typealias called PropertyList,
输入 typealias PropertyList = AnyObject

449
00:20:00,431 --> 00:20:02,831
which is equals AnyObject.

450
00:20:03,934 --> 00:20:08,302
Then I could have this type be PropertyList, okay?
接下来我就可以让 program: AnyObject 中的 AnyObject 成为 PropertyList 类型，明白了吗？

451
00:20:08,304 --> 00:20:11,772
So I just created PropertyList as an alias for AnyObject, so
这里我创建了 PropertyList 类型，它是 AnyObject 的一个替身

452
00:20:11,774 --> 00:20:13,106
someone looking at this is gonna go,
当别人看到这里的时候

453
00:20:13,108 --> 00:20:14,974
whoa, what the heck is PropertyList?
他会有一个疑问，究竟什么是 PropertyList

454
00:20:14,976 --> 00:20:16,309
Now they're going to look at this typealias, and
然后他们会回头看到这个 typealias

455
00:20:16,311 --> 00:20:18,844
say, oh, that's AnyObject, but they're really going to
然后知道，那是 AnyObject，但是他们会明确知道

456
00:20:18,846 --> 00:20:21,480
understand that I'm returning the Property List to them, and
我将返回一个 Property List 给他们

457
00:20:21,482 --> 00:20:22,848
the reason is Property List, again, so
原因还是 Property List

458
00:20:22,850 --> 00:20:26,584
I can throw it again as user defaults or whatever, okay?
我可以把它用作 NSUserDefaults 或者其他东西, 明白了吗？

459
00:20:28,354 --> 00:20:30,621
But otherwise, it's only good, the only thing it's good for
但是它只有在

460
00:20:30,623 --> 00:20:33,056
is giving it back to me to reset my program in
将来返回给我以重置 program 的时候才有用

461
00:20:33,058 --> 00:20:34,724
the future; that's all this thing is good for.
这个东西就是这一点有用

462
00:20:36,394 --> 00:20:39,762
Now, you're gonna wanna add this to your assignment for
现在，你们大概希望把这个加到你们的

463
00:20:39,764 --> 00:20:41,497
assignment three, okay?
作业三中

464
00:20:44,802 --> 00:20:47,502
So, all right, back to slides.
好的，回到我们的幻灯片中

465
00:20:48,571 --> 00:20:50,871
I'm not gonna, I don't have time to really run this
我并没有足够的课堂时间运行这个

466
00:20:50,873 --> 00:20:53,940
unfortunately due to in test code because we are
因为这个代码可能还需要调试，

467
00:20:56,178 --> 00:20:57,577
schedule constraint here.
可是我们的时间表有限制

468
00:20:57,579 --> 00:20:59,979
So let's go back to here, continue.
让我们继续

469
00:21:01,182 --> 00:21:03,415
All right, so now let's talk about, new thing here,
继续讨论一些新东西

470
00:21:03,417 --> 00:21:06,584
which is views, okay, totally new topic.
Views，全新的话题

471
00:21:06,586 --> 00:21:09,087
A view, that is to say,
一个 view

472
00:21:09,089 --> 00:21:12,156
a subclass of the class UIView in iOS
iOS 中 UIView 类的一个子类

473
00:21:12,158 --> 00:21:15,259
represents a rectangular area on the screen.
表示了屏幕上的一个长方形的区域

474
00:21:15,261 --> 00:21:17,861
That defines a coordinate space to draw in, and
定义了一个坐标系空间来绘图

475
00:21:17,863 --> 00:21:20,463
also to handle touch events, okay?
和处理触摸的操作，明白了吗？

476
00:21:20,465 --> 00:21:24,100
That's what a view is, and you are going to learn today,
这就是 view，你们今天要学的

477
00:21:24,102 --> 00:21:25,301
how to make your own views.
如何制作你们自己的 views

478
00:21:26,771 --> 00:21:29,638
The views are hierarchical, so,
views 是有层次的

479
00:21:29,640 --> 00:21:32,407
views are within views are within views.
这就意味着 views 可以在 views 中

480
00:21:32,409 --> 00:21:34,742
Any view only has one superview.
但是任何一个 view 都只能有一个 superview

481
00:21:34,744 --> 00:21:37,478
Right, it's only contained directly in one view.
这也就意味，一个 view 是直接包含在另一个 view 中的

482
00:21:37,480 --> 00:21:39,480
But, it can have any number of subviews.
但是一个 view 可以有多个 subview

483
00:21:39,482 --> 00:21:41,948
So in our Calculator, we had a top level view,
在我们的计算器程序中，我们有一个最高层的 view

484
00:21:41,950 --> 00:21:43,316
which I'm gonna talk about in a moment,
这个一会儿我会讲到

485
00:21:43,318 --> 00:21:45,752
and then we had a lot of subviews, all the buttons,
接下来我们有一大堆的 subviews，都是按钮

486
00:21:45,754 --> 00:21:49,221
the labels, those are all UIView subclasses.
和标签，它们是 UIView 的子类

487
00:21:49,223 --> 00:21:50,989
Okay, so we made a whole bunch.
所以我们将会用到一大堆

488
00:21:50,991 --> 00:21:53,091
A bunch of subviews in that view.
一大堆的 subviews，在最高层的 view 中

489
00:21:53,093 --> 00:21:54,225
But you can go even deeper.
但是你可以更深入地研究它

490
00:21:54,227 --> 00:21:55,593
It's hierarchical multi-layer.
这是个有层次的 multi-layer

491
00:21:55,595 --> 00:21:58,295
We can go as deep as we want.
我们想研究多深入都可以

492
00:21:58,297 --> 00:22:01,231
The two, you can see the two properties there for
在这里，你看到这两个 properties

493
00:22:01,233 --> 00:22:03,317
getting your superview.
用来获取你的 superview

494
00:22:03,318 --> 00:22:05,402
Notice it returns a Optional, because you
注意，它返回一个 Optional，这是因为

495
00:22:05,404 --> 00:22:07,804
can have a view that's not currently on screen.
你可以拥有一个当前不在屏幕中的 view

496
00:22:07,806 --> 00:22:10,406
It's not currently in the view hierarchy so that can be nil.
不在当前 view 层次结构中的 view 都会是 nil

497
00:22:11,509 --> 00:22:15,577
Your subviews, I show Array of UIView there.
还有一个属性是 subviews，这里我写的是一个 UIView 数组

498
00:22:15,579 --> 00:22:18,847
Actually the subview's property is an Array of AnyObject,
实际上这个 subview property 是一个 AnyObject 数组

499
00:22:18,849 --> 00:22:20,482
again for historical reasons, but
因为一些历史性的原因，不过

500
00:22:20,484 --> 00:22:21,849
there will always be UIViews in there.
元素始终都是 UIView 对象

501
00:22:21,851 --> 00:22:26,086
So don't even worry about that, okay?
所以不用担心，okay?

502
00:22:26,088 --> 00:22:28,588
And usually in this class on the the slides,
在这门课的幻灯片中，

503
00:22:28,590 --> 00:22:30,290
if something's an Array of AnyObject,
如果看到一个 AnyObject 数组

504
00:22:30,292 --> 00:22:32,258
if there's gonna be a certain kind of thing in there,
那就是里面肯定有某种特定的东西

505
00:22:32,260 --> 00:22:34,460
I'll say, Array of the certain kind of thing.
换言之，由某种特定的对象组成的数组

506
00:22:34,462 --> 00:22:36,628
But when you write your code, then,
但是当你编写自己的代码时

507
00:22:36,630 --> 00:22:40,565
obviously, you might see, oh, that's Array of AnyObject, and
很明显，你将会知道这是个 AnyObject 数组

508
00:22:40,567 --> 00:22:43,301
that's again, the bridging will work here,
再一次，桥接起作用了

509
00:22:43,303 --> 00:22:46,404
automatically, so, no worries there. UIWindow.
这一切都是自动完成的，不需要你操心。UIWindow

510
00:22:46,406 --> 00:22:48,372
There is a certain thing called a UIWindow.
有这么一个东西叫 UIWindow

511
00:22:48,374 --> 00:22:51,809
It's a subclass UIView but it has no meaning in iOS.
它是 UIView 的子类，但是在 iOS 开发中你不需要关心

512
00:22:51,811 --> 00:22:53,510
There is a UIWindow it's at the very,
在每一个设备屏幕上都会有一个 UIWindow

513
00:22:53,512 --> 00:22:56,913
very, very top of each device screen but
它在最高层上面

514
00:22:56,915 --> 00:22:59,515
you never send it any messages really.
但是你不会向它发送任何消息

515
00:22:59,517 --> 00:23:00,583
You don't interact with it.
你不跟它交互

516
00:23:00,585 --> 00:23:02,151
It's all about views.
在 iOS 中你只要关心 views

517
00:23:02,153 --> 00:23:04,152
On a desktop windows matter.
但是在桌面环境中，UIWindow 就很关键

518
00:23:04,154 --> 00:23:07,589
But on iOS, it's all about views, okay?
再次强调，在 iOS 中你只要关心 views，明白了吗？

519
00:23:07,591 --> 00:23:08,690
So don't worry about UIWindow.
不要操心 UIWindow

520
00:23:10,927 --> 00:23:13,127
This hierarchy of views, subviews and
views 的层次结构，subviews 和

521
00:23:13,129 --> 00:23:15,629
superviews, is created usually, graphically.
superviews 通常不需要通过代码来创建

522
00:23:15,631 --> 00:23:17,664
You can drag things out in the StoryBoard.
你可以直接从 StoryBoard 中拖出来这些组件

523
00:23:17,666 --> 00:23:20,800
You can drag views inside other views to
你可以在其他 views 中拖入 views

524
00:23:20,802 --> 00:23:23,102
create your hierarchy.
来创建你自己的层次结构

525
00:23:23,104 --> 00:23:25,104
But you can do it in code as well.
但是这并不是说不能用代码来创建这些东西

526
00:23:25,106 --> 00:23:28,674
It's pretty rare to do it in code, but you can.
很少人用代码创建图形部分，但是你可以这么做

527
00:23:28,676 --> 00:23:30,809
There's two methods here addSubview and
这里有两个方法：addSubview 和

528
00:23:30,811 --> 00:23:33,611
removeFromSuperview, addSubview is sent to
removeFromSuperview，addSubview 是

529
00:23:33,613 --> 00:23:35,446
the prospective superview.
向预期的 superview 发送的消息

530
00:23:35,448 --> 00:23:37,314
In other words to the place you wanna add your,
换言之，superview 是你想添加你的 view 的地方

531
00:23:37,316 --> 00:23:38,749
this view into.

532
00:23:38,751 --> 00:23:40,984
And removeFromSuperview is sent to the view that you
同样的，removeFromSuperview 是

533
00:23:40,986 --> 00:23:42,285
want to remove.
向你想要移除的 view 发送的消息

534
00:23:42,287 --> 00:23:44,571
So these are sent to different people,
这两个消息发送给不同的对象

535
00:23:44,572 --> 00:23:46,856
okay, removeFromSuperview means remove yourself from
removeFromSuperview 意味着把“你”自己从 superview 中

536
00:23:46,858 --> 00:23:47,556
your superview.
移除

537
00:23:49,493 --> 00:23:51,593
So, where does the view hierarchy start?
那么 view 的层次结构从那里开始呢？

538
00:23:51,595 --> 00:23:52,927
Where is the kind of the root,
它肯定有一个根节点

539
00:23:52,929 --> 00:23:55,596
the top level of this hierarchy, and
在层次结构的最顶上

540
00:23:55,598 --> 00:23:58,132
the answer is very simple, but, for some reason,
答案很简单，但是因为某些原因

541
00:23:58,134 --> 00:24:00,667
students have a very difficult time understanding this one.
学生们会很难理解这个概念

542
00:24:00,669 --> 00:24:04,737
There is a property in your UIView Controller
在你们的 UIView Controller 中有一个 property

543
00:24:04,739 --> 00:24:06,505
called view, and
名字叫 view

544
00:24:06,507 --> 00:24:11,209
it is the top level view in the scene in the StoryBoard.
这就是你们在 StoryBoard 场景中的最高层次的 view

545
00:24:11,211 --> 00:24:12,544
All right. So you have this StoryBoard.
这里你有这个 StoryBoard

546
00:24:12,546 --> 00:24:15,346
You've got your scene that we've seen like your
你有一个场景跟 Calculator 差不多的场景

547
00:24:15,348 --> 00:24:17,331
Calculator one.

548
00:24:17,332 --> 00:24:19,315
The top level one, the place where you're going to add
在视图层次中最高层（你将要添加

549
00:24:19,318 --> 00:24:22,720
your top level views, is called view in your View Controller.
你顶层 views 的地方）在 View Controller 中叫做 view

550
00:24:22,722 --> 00:24:24,688
It's just a property in UIView Controller.
它就是一个在 UIViewController 中的 property

551
00:24:24,690 --> 00:24:27,390
So it really couldn't be simpler, okay?
不能够更简单了吧

552
00:24:27,392 --> 00:24:29,859
Sometimes students they just forget that's there and
有时学生们忘记了 UIViewController 中还有这么一个 view

553
00:24:29,861 --> 00:24:32,495
ask how do I add something to my StoryBoard?
然后问：我怎么在我的 StordBoard 中添加东西呢？

554
00:24:32,497 --> 00:24:34,229
You know in code or something like that.
你想要从代码中实现

555
00:24:34,231 --> 00:24:37,065
Well you just you add it to the view of
你只需要把它加入 UIViewController

556
00:24:37,067 --> 00:24:40,502
your UIViewController, okay?
的 view 中，明白了吗？

557
00:24:40,504 --> 00:24:46,741
So, let's talk about initializing a view.
接下来让我们讨论一下初始化一个 view

558
00:24:46,743 --> 00:24:50,444
As usual, as I've kind of recommended, you probably want
通常我建议，不要做初始化

559
00:24:50,446 --> 00:24:52,946
to avoid doing an initializer, if you can.
尽可能不要

560
00:24:52,948 --> 00:24:55,782
So, to initialize any properties in
这里，在你的 view 中初始化

561
00:24:55,784 --> 00:24:58,584
your view hopefully using equals or
一些 properties 可以使用 = 来赋值

562
00:24:58,586 --> 00:25:00,953
some of the other ways we've talked about doing it.
或者我们说过的其他方法实现

563
00:25:00,955 --> 00:25:03,856
But, in UIView it's slightly more likely that you
但是，在 UIView 中有一点点相似的地方是

564
00:25:03,858 --> 00:25:05,724
might want to have an initializer.
你可能需要一个 initializer

565
00:25:05,726 --> 00:25:07,826
So it's a slightly complicated thing.
通常这个有一点点复杂

566
00:25:07,828 --> 00:25:08,926
Only slightly.
不过只有一点点

567
00:25:08,928 --> 00:25:11,262
In that UIView has two initializers you
UIView 中有两个 initializers 是

568
00:25:11,264 --> 00:25:12,730
have to deal with.
你需要处理的

569
00:25:12,731 --> 00:25:14,197
And that's because UIViews can be created in
那是因为 UIView 可以由两种不同的方法

570
00:25:14,200 --> 00:25:15,499
two different ways.
来创建

571
00:25:15,501 --> 00:25:18,468
In code by just saying UIView and
在代码中你会写 UIView(frame: CGRect)

572
00:25:18,470 --> 00:25:22,438
this frame initializer, which is just the frame in the superview,
这个 frame 就是 superview 的 frame

573
00:25:22,440 --> 00:25:26,042
coordinate system where this view is gonna live.
它是一个坐标系，这个 view 将在这个坐标系里面

574
00:25:26,044 --> 00:25:27,643
But then there's also this init with coder.
还有一个是 init(coder: NSCoder)

575
00:25:27,645 --> 00:25:29,311
And I'm not gonna talk about coders and
这里不打算讲 coders

576
00:25:29,313 --> 00:25:30,679
archiving and all that.
和归档的那些东西

577
00:25:30,681 --> 00:25:33,614
But that is the initializer that is called when the view
但是在 Storyboard 中初始化的时候会

578
00:25:33,616 --> 00:25:35,649
comes out of a StoryBoard.
调用 init(coder: NSCoder) 方法

579
00:25:35,651 --> 00:25:38,318
So, if you create a view by dragging on a StoryBoard,
所以，你在 StoryBoard 中拖入一个 view

580
00:25:38,320 --> 00:25:41,455
its initializer is this coder thing, okay?
它的初始化方法就会是 init(coder: NSCoder)，明白了吗？

581
00:25:41,457 --> 00:25:44,858
So, if you want, if you absolutely have to use
如果你想要，如果你不得不

582
00:25:44,860 --> 00:25:47,694
an initializer to initialize something in your UIView,
在你的 UIView 中使用一个 initializer 时

583
00:25:47,696 --> 00:25:50,329
you're gonna want to implement both of these things.
你就要实现这两个方法

584
00:25:50,331 --> 00:25:53,432
And I recommend this kind of format here.
这里我推荐的格式是

585
00:25:53,434 --> 00:25:57,669
Where you override init with frame there.
当你在这里 override init(frame: CGRect)

586
00:25:57,671 --> 00:26:00,271
That is a designated initializer in UIView.
这是一个UIView 的 designated initializer

587
00:26:00,273 --> 00:26:03,641
And then, there's actually a required initializer,
接下来，还有一个 requried 的 initializer

588
00:26:03,643 --> 00:26:05,042
which is the decoder one.
也就是 decoder 方法

589
00:26:05,044 --> 00:26:08,245
So if you implement the init with frame you have to
如果你实现了 init(frame: CGRect) 方法

590
00:26:08,247 --> 00:26:09,746
implement the coder one, it's required,
你必须同时实现 init(coder: NSCoder)，

591
00:26:09,748 --> 00:26:11,848
cuz as soon as you implement the init with frame,
因为只要是你实现了 init(frame: CGRect)

592
00:26:11,850 --> 00:26:14,216
you'll no longer inherit all of your designated
你就不再继承所有的 designated initializers

593
00:26:14,218 --> 00:26:17,052
initializers you won't inherit the init with the coder.
同样你不再继承 init(coder: NSCoder)

594
00:26:17,054 --> 00:26:18,787
So, basically implement them both, and
所以，简单来说就是实现这两者

595
00:26:18,789 --> 00:26:21,189
then just factor your initialization code into some
然后将这两个 initializer 分解成

596
00:26:21,191 --> 00:26:24,659
setup method or something, and call that, okay?
setup 方法或者其他的方法，然后调用分解出来的方法，明白了吗？

597
00:26:24,661 --> 00:26:26,827
So, that's only if you absolutely have to
当且仅当你不得不

598
00:26:28,064 --> 00:26:28,895
have an initializer.
自己实现一个 initializer 才这么做

599
00:26:30,365 --> 00:26:33,566
All right, there's another alternative to initializing.
好了，还有一个初始化的办法

600
00:26:33,568 --> 00:26:37,336
Which is if you can wait until the initialization is finished
那就是，如果你可以等初始化完成

601
00:26:37,338 --> 00:26:40,005
but you want something really early in the view's life,
但你真的需要在这个视图构造好之前做一些东西的话

602
00:26:40,007 --> 00:26:42,007
you can implement this method awakeFromNib.
你可以实现 awakeFromNib 方法

603
00:26:42,009 --> 00:26:43,508
But that only works for
但是只有 Storyboard 中的视图

604
00:26:43,510 --> 00:26:46,411
views that come out of a StoryBoard, okay?
才会调用这个方法，记住了吗？

605
00:26:46,413 --> 00:26:49,347
awakeFromNib means I just awoke from coming out of
awakeFromNib 表示，我刚刚从 Storyboard 中

606
00:26:49,349 --> 00:26:50,848
a StoryBoard.
被加载出来了

607
00:26:50,850 --> 00:26:53,617
So now you can initialize me.
你可以做一些初始化操作

608
00:26:53,619 --> 00:26:56,019
So it's a little bit limited, because it only is good for
不过这个方法使用很有局限性

609
00:26:56,021 --> 00:26:57,353
views that come out of a Storyboard.
因为它只是针对 Storyboard 中的视图

610
00:26:58,322 --> 00:26:59,488
But it is an alternative.
但是这确实是另外一种方法

611
00:27:00,557 --> 00:27:02,157
Now okay, so
好的

612
00:27:02,159 --> 00:27:04,726
that's all I'm going to say about that actually.
以上是关于视图初始化方面的内容

613
00:27:04,728 --> 00:27:06,827
Now let's go on to how do we.
现在我们来看看怎样在视图中

614
00:27:06,829 --> 00:27:09,663
Draw and handle events in this rectangular area.
绘制和处理触摸事件

615
00:27:09,665 --> 00:27:11,765
Well we need a coordinate system to work in.
我们需要一个坐标系来完成这些功能

616
00:27:11,767 --> 00:27:13,233
So there's some data structures I'm going to
所以我先会大致介绍一些

617
00:27:13,235 --> 00:27:16,736
show you real quick to get us started here, that we're
我们在绘制和处理触摸事件中

618
00:27:16,738 --> 00:27:19,939
gonna use when we're drawing and handling events.
需要用到的数据结构

619
00:27:19,941 --> 00:27:24,843
First of all, all coordinates are gonna be CGFloat.
首先，所有的坐标系的单位都是 CGFloat

620
00:27:24,845 --> 00:27:27,879
Okay, CGFloat is a type in Swift struct.
是的，CGFloat 在 Swift 中是结构体

621
00:27:27,881 --> 00:27:31,315
And always use CGFloat when you're drawing or
记住，在绘制和处理触摸事件的时候

622
00:27:31,317 --> 00:27:32,416
handling events in a view.
我们都用 CGFloat 类型

623
00:27:32,418 --> 00:27:33,684
Do not use Double.
不要用 Double 类型

624
00:27:33,686 --> 00:27:34,951
Do not use Float.
也不要用 Float 类型

625
00:27:34,953 --> 00:27:35,952
If you use those in your homework,
如果你在课后作业中使用 Double 和 Float 这些类型

626
00:27:35,954 --> 00:27:37,186
you're gonna get dying, okay?
这在程序里是行不通的

627
00:27:37,188 --> 00:27:38,020
CGFloat.
只能用 CGFloat

628
00:27:39,056 --> 00:27:40,322
Now Doubles and
你可以通过初始化方法

629
00:27:40,324 --> 00:27:44,059
Floats can be converted to a CGFloat using the initializer.
将 Double 和 Float 类型转换成 CGFloat 类型

630
00:27:44,061 --> 00:27:47,462
CGFloat has initializer for Float and Double.
你也可以通过 CGFloat 的初始化方法

631
00:27:47,464 --> 00:27:48,929
that you can pass and turn into a Float.
把 CGFloat 类型转换为 Double 或 Float 类型

632
00:27:48,931 --> 00:27:52,966
But, you always want things to be into CGFloat when you're
但是你在坐标系中操作的时候

633
00:27:52,968 --> 00:27:55,568
working in the coordinate system, okay?
你希望所有的东西都是 CGFloat 类型，对吧？

634
00:27:56,671 --> 00:27:58,571
Now, there's a couple other structures that
这里还有一些比较重要的

635
00:27:58,573 --> 00:27:59,538
are important here.
结构体

636
00:27:59,540 --> 00:28:00,472
One is CGPoint.
一个是 CGPoint

637
00:28:00,474 --> 00:28:03,274
It's just two Floats, X and Y.
它是由 x 和 y 两个 Float 类型组成的

638
00:28:03,276 --> 00:28:05,209
Just defines a point in the coordinate system.
它用来定义坐标系中的一个点

639
00:28:05,211 --> 00:28:06,210
Couldn't be simpler.
不能更简单了

640
00:28:06,212 --> 00:28:08,712
Okay? And there's also CGSize,
然后，另外一个是 CGSize

641
00:28:08,714 --> 00:28:09,846
just defines a width and
它在坐标系中定义

642
00:28:09,848 --> 00:28:11,815
a height in the coordinate system.
一个长和一个宽

643
00:28:11,817 --> 00:28:13,483
Okay, so these are just simple structs.
是的，就是一些简单的结构体而已

644
00:28:13,485 --> 00:28:14,517
That's all they are, structs.
他们都是结构体

645
00:28:14,519 --> 00:28:16,785
I don't know, certainly Point,
我不太确定，但貌似

646
00:28:16,787 --> 00:28:19,221
I don't think has any other methods on it or anything.
CGPoint 并没有其他的方法

647
00:28:19,223 --> 00:28:22,223
Size, maybe, I don't think so, though.
CGSize 可能有，不过我也不太确定

648
00:28:22,225 --> 00:28:24,726
But these two are combined, the points and
当 CGSize 和 CGPoint 组合在一起的时候

649
00:28:24,728 --> 00:28:27,928
the size, to CGRect.
就变成了 CGRect

650
00:28:27,930 --> 00:28:31,031
So CGRect is struct that has a point and a size.
CGRect 是由一个 CGPoint 类型的 point 和一个 CGSize 类型的 size 组成的结构体

651
00:28:31,033 --> 00:28:33,100
The point is the origin of the rect.
point 是这个矩形的原点

652
00:28:33,102 --> 00:28:34,734
Upper left, which I'm going to talk about in a second.
也就是矩形左上角的点，我稍后会详细解释的

653
00:28:34,736 --> 00:28:37,270
And then the size is the width and height.
然后 size 是矩形的宽和高

654
00:28:37,272 --> 00:28:40,740
Now rect has a lot of methods on it, okay?
CGRect 有很多方法

655
00:28:40,742 --> 00:28:42,708
Rect has things like minX,
比如说 minX

656
00:28:42,710 --> 00:28:44,242
which is the left edge of the rect.
它表示矩形的左边界

657
00:28:44,244 --> 00:28:48,112
Or midY, which is the midpoint of the rectangle vertically.
又比如说 midY，表示矩形垂直方向上的中点

658
00:28:48,114 --> 00:28:49,880
Or intersects.
还有 intersects 方法

659
00:28:49,882 --> 00:28:51,382
And you pass another Rect, and it'll tell you,
你传递另外一个矩形进去，它会返回一个布尔值

660
00:28:51,384 --> 00:28:53,650
Boolean, whether it intersects that Rect, right?
来判断这两个矩形是否相交

661
00:28:53,652 --> 00:28:55,251
The two Rects overlap.
也就是它们是否重叠

662
00:28:55,253 --> 00:28:57,887
Or, intercept, which says, take this other Rect and
或者，intercept 方法可以创建一个

663
00:28:57,889 --> 00:28:59,321
create a smaller rectangle,
更小的矩形

664
00:28:59,323 --> 00:29:01,457
which is the intersection of those two Rects.
这个小矩形是由两个矩形交叉的部分

665
00:29:02,459 --> 00:29:04,159
Or contains point.
还有一个 CGRect 的方法叫 contains

666
00:29:04,161 --> 00:29:05,560
Okay, we passed a point and
就是我们传递一个 CGPoint 类型的值进去

667
00:29:05,562 --> 00:29:07,461
it'll tell you whether it contains that point.
它告诉你这个点是否在矩形中

668
00:29:07,463 --> 00:29:09,563
So rect is this struct, but
所以，CGRect 这个结构体

669
00:29:09,565 --> 00:29:11,264
it has a lot of cool methods in there.
有很多很有意思的方法

670
00:29:11,266 --> 00:29:12,732
A whole bunch more.
一大堆的方法

671
00:29:12,734 --> 00:29:16,035
You can just type a rect, type and
你只需要键入 CGRect

672
00:29:16,037 --> 00:29:21,006
then a dot Xcode show you all the cool methods it has, okay?
然后输入一个点（表示方法调用），Xcode 会显示所有这些方法

673
00:29:21,008 --> 00:29:23,875
All right, so those are the types of data types we're
好的，以上所有这些结构体

674
00:29:23,877 --> 00:29:26,044
gonna use to talk about our coordinate system and
都是关于坐标系和在坐标系中操作

675
00:29:26,046 --> 00:29:27,979
to write our code in coordinate system.
时所需要用的数据结构

676
00:29:27,981 --> 00:29:30,915
So let's talk about the Views coordinate system itself.
接下来我们看看视图中的坐标系统

677
00:29:30,917 --> 00:29:33,283
First of all, origin upper left.
首先，原点在左上角

678
00:29:33,285 --> 00:29:35,652
Some of you might be used to origin lower left,
你或许遇到过原点在左下角的坐标系

679
00:29:35,654 --> 00:29:36,786
like Cartesian coordinates,
比如笛卡尔坐标系

680
00:29:36,788 --> 00:29:38,621
the origin is in the lower left.
它的原点就在左下角

681
00:29:38,623 --> 00:29:42,491
But all this origin that you're using a view is in
但是你在使用一个视图的时候，它的坐标原点

682
00:29:42,493 --> 00:29:44,543
the upper left.
都处于左上角

683
00:29:44,544 --> 00:29:46,594
So, that means increasing Y is down the screen,
也就是说，Y 轴向下延伸

684
00:29:46,597 --> 00:29:48,714
increasing X is across.
X 轴向右延伸

685
00:29:48,715 --> 00:29:50,832
So, I put an example, 500 dot 35, 500 comma 35, over there.
比如这里有一个点（500，35）

686
00:29:50,834 --> 00:29:53,801
It's 500 across, and only 35 down, okay?
它相对于左上角

687
00:29:53,803 --> 00:29:58,238
From the upper left.
向右500单位距离，向下35单位距离，明白吗？

688
00:29:58,240 --> 00:30:01,508
The units that we're talking about here are points
在这里我们用的单位是点

689
00:30:01,510 --> 00:30:02,342
not pixels.
不是像素

690
00:30:02,344 --> 00:30:03,476
Okay.
是的

691
00:30:03,478 --> 00:30:07,980
Pick high, very high resolution displays have more
高分辨率的屏幕中，每一个点可能表示

692
00:30:07,982 --> 00:30:10,282
than one pixel per point.
多个像素

693
00:30:10,284 --> 00:30:13,551
Okay, 'cuz they are able to draw very find curves,
因为这么做可以用来绘制非常平滑的曲线

694
00:30:13,553 --> 00:30:16,154
very fine text, et cetera.
和文本等（抗锯齿）

695
00:30:16,156 --> 00:30:17,956
You don't usually care
你通常不需要留心

696
00:30:17,957 --> 00:30:19,757
about the difference between points and pixels.
点和像素之间的区别

697
00:30:19,759 --> 00:30:20,991
It's automatically handled for
因为在你绘制文本或者曲线的时候

698
00:30:20,993 --> 00:30:23,126
you because you're doing things like drawing text or
这些东西会被自动处理，iOS 系统尽可能考虑

699
00:30:23,128 --> 00:30:26,162
drawing an arc and the system automatically uses as much
一个点到底应该占多少个像素

700
00:30:26,164 --> 00:30:28,464
pixels as it can to make things nice.
才能使绘制看上去更加完美

701
00:30:28,466 --> 00:30:30,132
But occasionally you do care,
但有些特殊的时候，你需要注意这些区别

702
00:30:30,134 --> 00:30:33,836
because maybe you're drawing something very finely detailed
特别是你需要处理和控制

703
00:30:33,838 --> 00:30:37,372
and you want to control pixel boundaries.
非常精细的细节和像素边界的时候

704
00:30:37,374 --> 00:30:39,708
And if you want to do that you can call this,
你可以访问你的视图中的一个属性

705
00:30:39,710 --> 00:30:42,610
get this property in view called contentScaleFactor
这个属性的名字是 contentScaleFactor

706
00:30:42,612 --> 00:30:46,180
and it will return the number of pixels per point.
它会返回给你每点占多少个像素的值

707
00:30:46,182 --> 00:30:48,182
So on a retina display, that's gonna be 2.
在视网膜屏（Retina）中，一个点表示2个像素

708
00:30:48,184 --> 00:30:51,184
On a non-retina display, that will be 1.
非视网膜屏中表示1个像素

709
00:30:51,186 --> 00:30:52,986
It could be anything, though.
当然在其他屏幕中或许是任意的值

710
00:30:52,988 --> 00:30:54,471
Okay?
明白吗？

711
00:30:54,472 --> 00:30:55,955
So you shouldn't write your code assuming it's 2 or 1.
所以你在代码里，不能直接写死2或1

712
00:30:55,957 --> 00:30:58,758
You should just write your code, get the contentScaleFactor
你在写代码的时候

713
00:30:58,760 --> 00:31:00,993
and you'll know how many pixels per point.
应该通过获取 contentScaleFactor 属性来知道这个值

714
00:31:00,995 --> 00:31:02,528
Okay?
记住了吗？

715
00:31:02,529 --> 00:31:04,062
99% of the time, you don't have to worry about this, but
百分之九十九的情况下，你不需要担心这个问题，但是

716
00:31:04,064 --> 00:31:07,065
in your assignment three, hint, hint, you might have to.
在课后作业3中，你可能需要处理这个问题

717
00:31:07,067 --> 00:31:07,632
Okay.
好的

718
00:31:09,502 --> 00:31:12,469
So what about the boundaries of where drawing happens.
那么，我们绘制区域的边界在哪里？

719
00:31:12,471 --> 00:31:13,870
You've got this rectangular area.
你已经有一个矩形区域

720
00:31:13,872 --> 00:31:17,107
Well, there's a very important property called bounds,
另外，有一个非常重要的属性，叫做 bounds

721
00:31:17,109 --> 00:31:20,910
which is a CGRect, which describes the area you're
它是 CGRect 类型，它定义了坐标系中

722
00:31:20,912 --> 00:31:25,047
drawing in in your own coordinate system.
的绘制区域

723
00:31:25,049 --> 00:31:26,081
Okay? It's important that it's in
明白吗？需要特别注意的是

724
00:31:26,083 --> 00:31:28,149
your own coordinate system.
绘制是相对于自身的坐标系

725
00:31:28,151 --> 00:31:32,553
Because these views can be scaled and even rotated and
因为视图可以被拉伸，旋转

726
00:31:32,555 --> 00:31:35,556
translated to other you know, coordinates systems.
或者变换等（父视图坐标系中）

727
00:31:35,558 --> 00:31:37,257
But when you're using the bounds and
但是你用 bounds 属性的时候

728
00:31:37,259 --> 00:31:39,926
you're drawing it yourself, you have this rectangle and
你是在自身坐标系绘制，你知道这个矩形

729
00:31:39,928 --> 00:31:42,495
you know where it is.
的确切位置

730
00:31:42,496 --> 00:31:45,063
Now the origin of your bounds usually is 0,0.
bounds 的原点通常是（0，0）

731
00:31:45,066 --> 00:31:46,865
But you could define it to mean something else, for
但是你可以更改它

732
00:31:46,867 --> 00:31:49,935
example, scroll views they define their origin to
比如，Scroll View 在滚动的时候会

733
00:31:49,937 --> 00:31:53,338
be where they are in the thing they're scrolling,
更改它的原点为目前滚动到的位置

734
00:31:53,340 --> 00:31:55,707
that's just what they define origin to be, but
这是 Scroll View 定义 bounds 原点的方式

735
00:31:55,709 --> 00:31:58,442
90% of the time, your origin is just going to be 0,0.
但是百分之九十的情况下，你的 bounds 的原点是（0，0）

736
00:31:58,444 --> 00:31:59,410
So, the width and
宽和高

737
00:31:59,411 --> 00:32:00,377
height is what you're going to care about,
才是你需要关心的

738
00:32:00,379 --> 00:32:02,212
how big a space am I drawing into.
我可以在多大的区域内绘制？

739
00:32:03,215 --> 00:32:06,082
There are two other properties that often get confused with
这里还有两个容易和 bounds 混淆的属性

740
00:32:06,084 --> 00:32:08,551
bounds, but don't let this happen to you.
我希望你不会混淆它们

741
00:32:08,553 --> 00:32:10,252
One is center.
一个是 center

742
00:32:10,254 --> 00:32:14,589
Center is the center of your view rectangle in your
center 是你自身视图矩形的中点

743
00:32:14,591 --> 00:32:17,158
superview's coordinate system, not in yours.
不过它是相对于父视图的坐标系，而不是自身坐标系的

744
00:32:18,127 --> 00:32:20,194
So if you write code that say, oh, I'm gonna start to
如果你这样写代码，我将在矩形中心

745
00:32:20,196 --> 00:32:23,063
draw something in middle of my rectangle.
绘制一些东西

746
00:32:23,065 --> 00:32:24,297
I'll get center.
我使用 center

747
00:32:24,299 --> 00:32:25,098
Aah!

748
00:32:25,100 --> 00:32:26,516
That's wrong.
这样就会出问题了

749
00:32:26,517 --> 00:32:27,933
Okay? Center is in your super view.
明白了吗？center 是相对于父视图的坐标系

750
00:32:27,935 --> 00:32:29,368
Center positions you.
center 定义你在父视图的位置

751
00:32:29,370 --> 00:32:31,470
It has nothing to do with how you draw.
它和绘制操作没有关系

752
00:32:31,472 --> 00:32:33,805
It just says where you are in your super view.
它仅仅用来在你父视图中定位

753
00:32:33,807 --> 00:32:36,674
Same thing, frame, frame is a rectangle in your
同样，frame 是父视图坐标系中

754
00:32:36,676 --> 00:32:40,277
super view's coordinate system that contains you.
用来包含子视图的一个矩形

755
00:32:40,279 --> 00:32:43,847
Okay, it contains all of you, of your drawing.
是的，它包含子视图的所有区域，包括绘制部分

756
00:32:43,849 --> 00:32:45,615
But it's in your super user coordinates systems so
但是它是相对于父视图的坐标系

757
00:32:45,617 --> 00:32:48,385
it's only good to position you, not for drawing.
所以它只是用来定位子视图，与绘制无关

758
00:32:48,387 --> 00:32:50,186
When you're drawing, you use bounds.
绘制的时候，你使用 bounds

759
00:32:50,188 --> 00:32:52,421
To kind of give you a picture of this,
为了更形象地说明这个

760
00:32:52,423 --> 00:32:55,057
as better like you might think that
你可以这样认为

761
00:32:55,059 --> 00:32:59,361
the frame size is exactly the same as the bound size.
frame 的 size 和 bounds 的 size 总是相同的

762
00:32:59,363 --> 00:33:02,563
Right, if it's a rectangle that contains my rectangle,
如果一个矩形要完全包含我

763
00:33:02,565 --> 00:33:04,932
it must be exactly the same size.
它必须和我的尺寸一样大

764
00:33:04,934 --> 00:33:07,734
But no, because view can be rotated.
但也有例外，因为视图可以被旋转

765
00:33:08,704 --> 00:33:10,487
Okay? And
明白了吗？

766
00:33:10,488 --> 00:33:12,271
if you rotate your view like this green view,
如果你像这个绿色视图这样，旋转你的视图

767
00:33:12,273 --> 00:33:14,707
look how much bigger the frame is.
你可以看到，frame 要大的多

768
00:33:14,709 --> 00:33:18,410
The rectangle that contains you is much bigger than you.
包含你的矩形，要比你自己大得多

769
00:33:18,412 --> 00:33:19,878
Because you're tilted.
因为你是倾斜的

770
00:33:19,880 --> 00:33:20,578
All right?
没问题吧？

771
00:33:21,814 --> 00:33:24,014
Make sense?
清楚了吗？

772
00:33:24,015 --> 00:33:26,215
So don't confuse frame and center, which are about
所以不要混淆了，frame 和 center 是用来定位视图的

773
00:33:26,218 --> 00:33:30,420
positioning, with bounce which is your size and
而 bounds 是用来在视图自身的坐标系中

774
00:33:30,422 --> 00:33:33,623
area that you're drawing into in your own coordinate system.
确定大小和区域的

775
00:33:36,127 --> 00:33:37,059
Okay?
明白吗？

776
00:33:37,060 --> 00:33:37,992
Okay, so creating views.
接下来，视图的创建

777
00:33:37,995 --> 00:33:38,527
How do we create views?
我们怎样创建一个视图？

778
00:33:42,533 --> 00:33:45,333
Most often views are created by dragging them out to
大部分的视图是直接

779
00:33:45,335 --> 00:33:46,801
the Storyboard.
通过 Storyboard 生成的

780
00:33:46,803 --> 00:33:50,104
That's 95% of the time.
大概百分之九十五都是这样

781
00:33:50,106 --> 00:33:52,123
And af, but
但是

782
00:33:52,124 --> 00:33:54,141
of course, your views aren't sitting in the Object Pallet,
官方视图可能不能满足你的需要

783
00:33:54,143 --> 00:33:57,577
there's buttons and sliders, but there's no your view.
这里有按钮，滑条等，但是可能没有你需要的视图

784
00:33:57,579 --> 00:34:00,113
So you have to drag it out of generic view.
这时候，你就需要先拖一个通用的视图（UIView）

785
00:34:00,115 --> 00:34:01,681
It's kind of at the bottom of the pallet and
就在控件区的底部

786
00:34:01,683 --> 00:34:02,782
you just drag it out.
拖出来就可以了

787
00:34:02,784 --> 00:34:05,051
Once you drag it out though,
一旦你拖出来这个视图后

788
00:34:05,052 --> 00:34:07,319
you have to go to the Identity Inspector and change the class
你需要在它的 Identity Inspector 里

789
00:34:07,321 --> 00:34:10,989
of that view that you dragged out, so that it's your class.
把对应的类修改你自己的实现类

790
00:34:10,991 --> 00:34:12,457
Okay? So it's a two step process.
明白吗？需要两步来完成这个操作

791
00:34:12,459 --> 00:34:15,093
You drag a view, your custom view out and then you change
先拖一个通用的视图出来

792
00:34:15,095 --> 00:34:19,930
this class to view whatever your custom class is on rare
然后把对应的类改为你自己的类

793
00:34:19,932 --> 00:34:24,034
occasion, you might create an instance of your view in code.
只有在很少情况下，你才需要用纯代码创建视图

794
00:34:25,036 --> 00:34:26,569
Probably never in this class,
至少本课程范围内，你不需要这样做

795
00:34:26,571 --> 00:34:29,938
maybe in your final project, although I doubt it.
大作业上可能会用到

796
00:34:29,940 --> 00:34:34,442
You just do that using UIView's frame initializer.
你可以通过一个特殊的构造器

797
00:34:34,444 --> 00:34:35,376
Right? So you just say
来通过代码创建一个视图

798
00:34:35,378 --> 00:34:36,644
view equals UIView frame.
这里你输入 view = UIView(frame: ...)

799
00:34:38,214 --> 00:34:40,414
You can even do UIView with no arguments and
甚至你也可以不传参数给这个构造器

800
00:34:40,416 --> 00:34:43,283
it'll give you a CGRect to zero which is a frame zero
这样的话，它返回给你一个空视图（CGRectZero），也就是说这个视图的

801
00:34:43,285 --> 00:34:45,485
size and width and
size 和 frame 都是0

802
00:34:45,486 --> 00:34:47,686
then you could later set its frame to position the view.
稍后，你可以再设置这个视图的 frame 来确定位置

803
00:34:47,689 --> 00:34:50,189
So here's an example of creating a view in code.
这里有一个使用代码创建视图的例子

804
00:34:50,191 --> 00:34:51,590
I'm going to use UILabel.
我接下来要使用 UILabel 控件

805
00:34:51,592 --> 00:34:55,093
UILabel is a subclass of UIView so I can send it.
UILabel 是 UIView 的一个子类，所以我可以使用带 frame 参数的构造器

806
00:34:55,095 --> 00:34:57,495
UILabels parentheses frame.
UILabel(frame: ...)

807
00:34:57,497 --> 00:34:59,263
So I just give it this frame which is kind of in
我传入一个 frame

808
00:34:59,265 --> 00:35:00,698
the upper left.
这个 frame 会让视图设置在左上方的位置

809
00:35:00,700 --> 00:35:04,334
Notice I've created this view but it's not on screen yet.
注意，我已经创建了这个视图，但是它并没有显示在屏幕上

810
00:35:04,336 --> 00:35:06,003
Okay.

811
00:35:06,004 --> 00:35:07,671
Assuming this code here is in a View Controller,
假设这里的代码是在一个 View Controller 里

812
00:35:07,673 --> 00:35:10,640
I could then say view.addSubview.
我接下来可以输入 view.addSubview

813
00:35:10,642 --> 00:35:12,475
Cuz remember view is a property in
还记得 view 是一个在我的 View Controller 中的一个属性吗？

814
00:35:12,477 --> 00:35:15,144
my View Controller which is that top level view.
它指向了 View Controller 中最顶层的那个视图

815
00:35:15,146 --> 00:35:17,279
And I could say add subview of the label and
这里我输入，view.addSubview(label)

816
00:35:17,281 --> 00:35:18,613
boom, it'll appear on screen.
这样，这个视图就出现在屏幕上了

817
00:35:19,616 --> 00:35:20,514
Okay? At 20,20 ,
在（20，20）的位置上

818
00:35:20,516 --> 00:35:22,716
width 100, height 50.
宽度是100，高度是50

819
00:35:22,718 --> 00:35:23,283
Okay?
明白了么？

820
00:35:25,120 --> 00:35:26,619
So it is possible to create views in code.
所以可以完全通过代码来创建一个视图

821
00:35:26,621 --> 00:35:28,821
We almost never do that in iOS.
不过 iOS 开发中几乎不这么做

822
00:35:28,823 --> 00:35:29,855
We use Storyboard.
我们使用 Storyboard

823
00:35:31,458 --> 00:35:35,727
Okay, so when do I wanna create my own UIView?
那么，什么时候我们会想创建一个自己的 UIView 呢？

824
00:35:35,729 --> 00:35:36,660
Right?
嗯？

825
00:35:36,662 --> 00:35:38,162
Well, when don't you want to?
换一个思路，什么时候我么你不想创建一个自己的 UIView

826
00:35:38,164 --> 00:35:40,597
Well you don't want to if you want a button or a slider or
当你只是需要一个按钮或者 Slider 或者任何东西

827
00:35:40,599 --> 00:35:43,099
anything where there's already an iOS view.
这些已经存在于 iOS 系统的控件库中的时候，你不需要自己创建一个 UIView

828
00:35:43,101 --> 00:35:44,400
But if you want to do something that
但是如果你想要做一些

829
00:35:44,402 --> 00:35:47,303
those things can't do, draw something special or
特别的事情，比如绘制一些其他图形

830
00:35:47,305 --> 00:35:49,538
handle touch events like swipes and
或者想让触摸事件，例如 Swipes 和

831
00:35:49,540 --> 00:35:54,509
taps and pinches, differently or for a different purpose.
Taps 以及 Pinches 手势，有着不同的处理方式

832
00:35:54,511 --> 00:35:58,212
Then those things then you create your own custom view.
那么你这时候，你想要创建自己的 UIView

833
00:35:58,214 --> 00:36:00,581
So, we're going to focus on drawing today, and
所以，我们今天将会专注于绘制

834
00:36:00,583 --> 00:36:03,984
I'll do gestures in the next lec, in the next lecture.
然后在下节课我将会讲触摸手势识别相关的内容

835
00:36:03,986 --> 00:36:05,585
To draw in your UIView,
在你的 UIView 中绘制时

836
00:36:05,587 --> 00:36:09,155
all you need to do is override this method drawRect.
你需要重写 drawRect 方法

837
00:36:10,591 --> 00:36:13,425
Okay, very simple method only takes one argument.
一个非常简单的方法，它只接受一个参数

838
00:36:13,427 --> 00:36:15,594
In the code, it's actually called Rect, but
在代码中，这个参数实际上叫做 rect

839
00:36:15,596 --> 00:36:18,697
I've renamed it to be regionThatNeedsToBeDrawn, so
但是我已经将它重新命名为 regionThatNeedsToBeDrawn

840
00:36:18,699 --> 00:36:20,798
that people understand what that argument is.
这样人们就可以更好理解 rect 参数是什么意思

841
00:36:20,800 --> 00:36:23,734
That argument is purely an optimization.
那个参数纯粹是起一个优化效果

842
00:36:23,736 --> 00:36:27,338
It's just the system saying, hey, draw yourself and really,
这个参数告诉系统，当你绘图的时候

843
00:36:27,340 --> 00:36:29,339
I only care about this rectangle of you.
我只是关心参数的这个区域

844
00:36:29,341 --> 00:36:31,641
But you can draw your, the whole self if you want.
当然你可以绘制整个，整个你想要的视图区域

845
00:36:31,643 --> 00:36:33,609
But this is the only rectangle I really care about.
但是只有这个矩形范围，才是我真正关注的

846
00:36:33,611 --> 00:36:37,279
So if you had a View that knew how to draw parts of itself,
所以如果你有一个视图，而且视图知道如何去绘制它的部分区域

847
00:36:37,281 --> 00:36:40,182
okay, then it could only draw the part that's in
那么这个方法只会绘制

848
00:36:40,184 --> 00:36:41,650
this rectangle, but
参数这个矩形区域内的部分

849
00:36:41,651 --> 00:36:43,117
you can completely ignore this rectangle if you want.
当然你可以完全忽略你想要的这个矩形范围

850
00:36:43,120 --> 00:36:45,387
It's purely an optimization.
它纯粹的起一个优化效果

851
00:36:45,389 --> 00:36:45,953
Okay?
明白了吗？

852
00:36:48,124 --> 00:36:49,990
This is very important to understand,
下面这个概念是相当重要的

853
00:36:49,992 --> 00:36:53,260
you never call drawRect, ever, never.
“永远不要调用 drawRect 方法”

854
00:36:53,262 --> 00:36:54,160
Never.
永远不要

855
00:36:54,162 --> 00:36:55,345
Okay?

856
00:36:55,346 --> 00:36:56,529
If you call drawRect in your homework,
如果你在你的课后作业中调用了 drawRect 方法

857
00:36:56,531 --> 00:36:58,330
you're going to be a major ding.
你会得到一个很糟糕的分数

858
00:36:58,332 --> 00:36:59,999
Because I'm standing here in front of
因为我站在这里，站在

859
00:37:00,001 --> 00:37:01,600
you with red text on my slide.
我 Slide 上的红色文字之前

860
00:37:01,602 --> 00:37:03,034
Saying, never.
告诉你，永远不要这么做

861
00:37:03,036 --> 00:37:05,153
Okay.

862
00:37:05,154 --> 00:37:07,271
Do not call drawRect, drawRect is called by the system.
不要调用 drawRect 方法，drawRect 方式是被系统调用的

863
00:37:07,273 --> 00:37:09,190
Okay?
明白了吗？

864
00:37:09,191 --> 00:37:11,108
It's called by the system when your view needs to be redrawn.
当你的视图需要重新绘制时，它会自动被系统调用

865
00:37:11,110 --> 00:37:13,010
How does the system know your needs,
那么你们会问，系统是怎样知道你需要重绘这个视图呢？

866
00:37:13,012 --> 00:37:14,578
view needs to be redrawn?
重绘这个视图呢？

867
00:37:14,580 --> 00:37:18,314
Because somebody called setNeedsDisplay on your view.
在你的视图里，有一个叫做 setNeedDisplay 的方法

868
00:37:18,316 --> 00:37:19,982
And you can call it on yourself if you want.
如果你需要重绘视图的话，你可以调用它

869
00:37:19,984 --> 00:37:22,985
If something has changed about your view, some property or
如果在你的视图中有内容发生变化时

870
00:37:22,987 --> 00:37:24,887
something that would change the way it's drawn,
比如一些属性或者一些东西的改变

871
00:37:24,889 --> 00:37:26,888
you call setNeedsDisplay on yourself,
你可以对自身调用 setNeedsDisplay 方法

872
00:37:26,890 --> 00:37:29,691
eventually the system will call your drawRect.
最终，系统会在合适的时机调用你的 drawRect 方法

873
00:37:29,693 --> 00:37:31,993
But it's got to set some things up first, okay.
但是首先，它会设置某些东西

874
00:37:31,995 --> 00:37:33,928
There's other views around you.
在你周围有其他的视图

875
00:37:33,930 --> 00:37:36,330
That it has to get organized.
它们必须先被组织起来

876
00:37:36,332 --> 00:37:38,965
Okay, so never call drawRect, drawRect it's called for you.
所以，永远不要调用 drawRect，drawRect 会自动被系统调用的

877
00:37:38,967 --> 00:37:42,002
When you call setNeedsDisplay, you can specify I
当你调用 setNeedsDisplay 的时候

878
00:37:42,004 --> 00:37:44,303
really only need this rectangle redisplayed and
你可以指定，你只需要某个特定的范围来重绘

879
00:37:44,305 --> 00:37:45,905
then obviously,
接下来

880
00:37:45,906 --> 00:37:47,506
that rectangle's gonna show up in the argument to drawRect.
那块区域将会以参数形式传递给 drawRect 方法

881
00:37:48,609 --> 00:37:51,143
Okay, but if multiple people call set in use display with
好的，如果当很多人在用不同的矩形范围上

882
00:37:51,145 --> 00:37:53,345
different rectangles, probably the union of those
调用 setNeedsDisplay 的时候，可能这些区域的并集

883
00:37:53,347 --> 00:37:56,280
rectangles might get called here one time for drawRect.
会作为参数被 drawRect 方法一次调用完成

884
00:37:56,282 --> 00:37:57,581
Okay?
明白了么？

885
00:37:57,583 --> 00:38:00,517
Make sense?
听懂了么？

886
00:38:00,519 --> 00:38:01,418
All right.

887
00:38:01,420 --> 00:38:03,186
So, how do you implement this, pow,
所以，你要怎样实现这个

888
00:38:03,188 --> 00:38:05,922
all-powerful drawRect method?
无所不能的 drawRect 方法呢？

889
00:38:05,924 --> 00:38:09,625
You can use, kind of a C-like, function-based API,
你可以使用，类似于 C 语言，基于函数的 API

890
00:38:09,627 --> 00:38:11,259
called Core Graphics.
叫做 Core Graphics

891
00:38:11,261 --> 00:38:13,094
That's what it's all based on.
它是所有图像绘制的基础

892
00:38:13,096 --> 00:38:15,596
Or you can use a nice object-oriented, thing,
或者你可使用一种更高层次、面向对象的做法

893
00:38:15,598 --> 00:38:18,432
called UIBezierPath, which is what we're gonna use,
叫做 UIBezierPath，这就是我们接下来要使用的

894
00:38:18,434 --> 00:38:20,367
because we like object-oriented.
因为我们偏向于用一些高层次的 API

895
00:38:20,369 --> 00:38:23,603
But since the underlying stuff core graphics is what
但是，因为涉及到图形绘制底层的东西

896
00:38:23,605 --> 00:38:26,973
UIBezierPath is built on, I'm gonna kinda explain a little
我会介绍一些 Core Graphics 的概念

897
00:38:26,975 --> 00:38:29,442
bit about the concepts of Core Graphics.
它是构建 UIBezierPath 的核心和基础

898
00:38:29,444 --> 00:38:31,944
How one draws in Core Graphics.
一个东西是怎么样在 Core Graphics 中绘制的？

899
00:38:31,946 --> 00:38:34,380
The first thing in Core Graphics that's important is,
在 Core Graphics 中第一件很重要的事是

900
00:38:34,382 --> 00:38:37,416
you have to get a context to draw in.
你得拥有一个用来绘制的上下文（context）

901
00:38:37,418 --> 00:38:38,700
Okay?
明白了吗？

902
00:38:38,701 --> 00:38:39,983
So if you're printing you'll have a printing context.
如果你要 printing 那你得有一个 printing 的 context

903
00:38:39,986 --> 00:38:41,519
If you're drawing on screen you'll have a draw on
如果你要在屏幕上绘制你得有一个

904
00:38:41,521 --> 00:38:44,305
screen context, et cetera.
可以绘制的屏幕 context，等等

905
00:38:44,306 --> 00:38:47,090
And inside drawRect, when you're drawRect is called by
在 drawRect 中，当你准备绘制时

906
00:38:47,093 --> 00:38:50,227
the system, it sets up the drawing context for you.
系统会调用 drawRect 方法并且为你建立一个绘制的 context

907
00:38:50,229 --> 00:38:51,895
So it's automatically set up,
所以它是自动建立的

908
00:38:51,897 --> 00:38:54,097
and it's called the current context,
并且它被称为当前的 context

909
00:38:54,099 --> 00:38:55,431
the current drawing context.
当前的绘制 context

910
00:38:55,433 --> 00:38:58,233
And you can get it if you were using the C-API.
同时如果你使用 C-API 你也可以得到它

911
00:38:58,235 --> 00:39:01,837
Or C-like APIs it's still Swift but it's functional.
或者C-like APIs 它仍然是 Swift 但是它是实用的

912
00:39:01,839 --> 00:39:03,405
Function API, you can get it
API 函数，你可以得到他们

913
00:39:03,407 --> 00:39:06,207
with this function UIGraphicsGetCurrentContext.
通过 UIGraphicsGetCurrentContext 方法

914
00:39:06,209 --> 00:39:07,541
And it will return this cookie,
它将会返回到这个 cookie

915
00:39:07,543 --> 00:39:08,876
it's just this magic cookie.
它只个令人惊奇的 cookie

916
00:39:08,878 --> 00:39:11,411
You don't know what it is, but it is the context of drawing.
你不知道它是什么，但是它是绘制时的 context

917
00:39:11,413 --> 00:39:15,615
Because all of the C-like functional API take
因为所有的 C-like 函数的 API

918
00:39:15,617 --> 00:39:17,483
a context as an argument.
使用 context 作为参数

919
00:39:17,485 --> 00:39:20,786
Okay, BezierPath doesn't do that no worries,
Okay，BezierPath 不会这样做，不用担心

920
00:39:20,788 --> 00:39:22,521
but that one does.
但是那个会这么做

921
00:39:22,522 --> 00:39:24,255
So the first thing you need is a context automatically set up
所以你需要做的第一件事是自动创建一个 context

922
00:39:24,258 --> 00:39:25,824
for your when drawRect is called.
当你的 drawRect 被调用时

923
00:39:25,826 --> 00:39:29,927
Then you create paths, you create paths with lines and
然后你创建路径，通过线条和

924
00:39:29,929 --> 00:39:31,395
arcs and things like that.
弧线以及诸如此类的东西创建路径

925
00:39:32,297 --> 00:39:33,930
Then you set the drawing attributes,
然后你设置绘制的属性

926
00:39:33,932 --> 00:39:36,499
like the colors you want to draw in, the linewidths, and
比如你希望绘制的颜色，线条宽度

927
00:39:36,501 --> 00:39:37,800
things like that, and
和类似于这些的东西

928
00:39:37,802 --> 00:39:41,370
finally, you stroke and fill those paths.
最后你描边并且填充这些路径

929
00:39:42,305 --> 00:39:44,122
Okay?
明白了么？

930
00:39:44,123 --> 00:39:45,940
And you can do either, or, or both stroking and filling.
你可以做任意一个，或者同时做两个

931
00:39:45,942 --> 00:39:48,509
So that is how, that is fundamentally how you draw.
因此这就是你绘制的基础

932
00:39:48,511 --> 00:39:52,979
Things like drawing text is just the fonts know how to
类似于绘制文字之类的事情只是需要知道字体

933
00:39:52,981 --> 00:39:56,049
have the perfect path to draw beautiful letters.
并且如何获得一个完美的路径来绘制漂亮的字母

934
00:39:56,051 --> 00:39:58,918
And so, your stroking would outline the letters, and
所以，你的描边将描绘出字母的轮廓

935
00:39:58,920 --> 00:40:01,620
filling fills in the letters, okay?
然后填充到字母的内部，明白？

936
00:40:01,622 --> 00:40:05,023
So even drawing text, is just stroking and filling paths.
所以即使是绘制文字，也只需要描边和填充的路径

937
00:40:06,093 --> 00:40:10,061
Okay? Now, UIBzierPath, this object-oriented
明白了么？现在，UIBzierPath，这个面向对象的

938
00:40:10,063 --> 00:40:12,830
thing on top, it always draws in the current context,
东西在最上面，它通常在当前的 context 上绘制

939
00:40:12,832 --> 00:40:14,431
you don't have to worry about context.
你不用担心这个 context

940
00:40:14,433 --> 00:40:17,934
It has methods, to do things like line two, arch two,
它有很多方法，去做一些类似于两个线条，两个弧线的东西

941
00:40:17,936 --> 00:40:19,069
to build the path.
用来建立路径

942
00:40:19,071 --> 00:40:20,821
It also has methods for
它同样拥有很多方法

943
00:40:20,822 --> 00:40:22,572
setting a lot of these attributes like linewidth and
用来设置很多属性例如线宽

944
00:40:22,574 --> 00:40:25,174
things like that and it has methods to stroke and fill.
和一些类似的属性同时它还有很多方法去描边和填充

945
00:40:25,176 --> 00:40:28,243
So combine all those Core Graphics things into one class.
所以将所有的 Core Graphics 放到一个类里

946
00:40:28,245 --> 00:40:30,012
So let's look at UIBezierPath, and
让我们来看一下 UIBezierPath

947
00:40:30,014 --> 00:40:32,747
how we would use it to draw a triangle, let's say.
和我们怎样使用它绘制一个三角形，比如说

948
00:40:34,183 --> 00:40:37,418
First we create a path, so we just say, UIBezierPath.
首先，我们创建一个路径，比方说，UIBezierPath

949
00:40:37,420 --> 00:40:40,320
There are other initializers for UIBezierPath but
有其他的 UIBezierPath 初始化方法

950
00:40:40,322 --> 00:40:42,889
you could also just create an empty path, and
但是你也可以只建立一个空的路径

951
00:40:42,891 --> 00:40:45,625
then you can start moving around.
然后你就可以开始在周围移动了

952
00:40:45,627 --> 00:40:50,195
So, here I'm going to assume this screen is 160 points wide
所以，在这里我们假设这个屏幕是 160 * 250

953
00:40:50,197 --> 00:40:53,965
by 250 wide, and I'm gonna draw, this triangle here.
然后我准备在这里绘制一个三角形

954
00:40:53,967 --> 00:40:57,102
So I'm gonna move to 80 which is halfway across and
所以我准备移动 80 个点，大概在屏幕中间

955
00:40:57,104 --> 00:40:58,369
50 which is a little bit down,
和 50 个点一点点下降

956
00:40:58,371 --> 00:41:03,607
and then I'm going to add a line down to 140, 150.
然后我将要添加一条线向下到 140，150

957
00:41:03,609 --> 00:41:06,743
Then I wanna another line over to 10, 150.
接下来我想再添加另一条线到 10，150

958
00:41:06,745 --> 00:41:10,446
Then I'm going to close this path.
然后我将会关闭这个路径

959
00:41:10,448 --> 00:41:11,681
Okay?
看明白了么？

960
00:41:11,682 --> 00:41:12,915
So that's it, that's how you can make a triangle.
所以，这是这样，这就是如何绘制一个三角形

961
00:41:12,917 --> 00:41:16,285
Now, I'm kind of lying to you a little bit, because as you
现在，我有点儿欺骗了你们一下，因为当你们

962
00:41:16,287 --> 00:41:18,687
execute these, nothing is appearing on screen.
这么做的时候，屏幕上什么也不会出现

963
00:41:18,689 --> 00:41:21,389
The screen will be blank.
屏幕将会一片空白

964
00:41:21,391 --> 00:41:23,891
Okay, I was only showing them so you could understand what I
Okay，我只是向你们展示它们，这样你就可以理解

965
00:41:23,893 --> 00:41:25,726
was doing there with the lines.
我在这儿通过这些线做了什么

966
00:41:25,728 --> 00:41:27,278
So it'd be blank.
所以它将会一篇空白

967
00:41:27,279 --> 00:41:28,829
To make it appear, you have to stroke or fill.
要让它出现，你必须描边或者填充

968
00:41:28,831 --> 00:41:31,331
So, let's set the attributes we want.
所以，让我们设置我们需要的属性

969
00:41:31,333 --> 00:41:34,300
So, I'm gonna set the color for filling to be green, and
所以，我将填充的颜色设置为绿色

970
00:41:34,302 --> 00:41:37,403
the color for stroking to be red.
描边的颜色设置为红色

971
00:41:37,405 --> 00:41:41,007
Okay, now notice that I set those with methods on UIColor,
Okay，现在注意我是通过 UIColor 的方法设置这些属性

972
00:41:41,009 --> 00:41:43,409
not with methods on the BezierPath.
不是通过 BezierPath 的方法

973
00:41:43,411 --> 00:41:46,144
Okay, that's a little interesting but
Okay，那是有一点有趣但是

974
00:41:46,146 --> 00:41:47,679
that's the way that works.
它就是那样工作的

975
00:41:47,681 --> 00:41:51,015
But linewidth, I do step by talking to the paths, so
但是线宽，我得通过和路径进行沟通来做

976
00:41:51,017 --> 00:41:52,316
I sent a message to the BezierPath,
所以我发送一个消息到 BezierPath

977
00:41:52,318 --> 00:41:53,650
set linewidth the three.
设置线条的宽度为 3

978
00:41:53,652 --> 00:41:57,254
So once I set up all my attributes, now I can fill,
所以当我设置我所需要的全部属性后，现在我可以填充

979
00:41:57,256 --> 00:41:58,988
for example by saying, path fill and
比方说，填充路径

980
00:41:58,990 --> 00:42:01,791
see, I get the rectangle filled in green.
看，我得到了一个填充为绿色的三角形

981
00:42:01,793 --> 00:42:05,127
Or, I can say stroke and it'll stroke the red line.
或者说，我可以给它描边，它将会变成红边

982
00:42:05,129 --> 00:42:07,696
Okay?
明白了么?

983
00:42:07,698 --> 00:42:10,098
Pretty straightforward?
很简单吧？

984
00:42:10,100 --> 00:42:12,100
Most of learning to draw is all about
大多数的学习绘制全都关于

985
00:42:12,102 --> 00:42:14,568
understanding UIBezierPath and all the methods on it.
理解 UIBezierPath 和它全部的方法

986
00:42:14,570 --> 00:42:15,269
Question back there?
这里有什么问题么？

987
00:42:16,438 --> 00:42:18,038
>> if I have two shapes onscreen,
-（学生提问）如果我在屏幕上有两个图形

988
00:42:18,040 --> 00:42:20,707
>> how would I set the colors be different for each one?
- 我怎么样给每个图形不同的颜色呢？

989
00:42:20,709 --> 00:42:21,875
If you have two what?
如果你有两个什么？

990
00:42:21,876 --> 00:42:23,042
>> If you have two different shapes onscreen?
- 如果你在屏幕上有两个图形

991
00:42:23,044 --> 00:42:23,976
Oh, yes. So, the question,
哦，是的，这就是问题

992
00:42:23,978 --> 00:42:25,210
if I have two shapes onscreen,
如果我在屏幕上有两个图形

993
00:42:25,212 --> 00:42:27,912
how would I set the colors be different for each one?
我怎么样给每个图形不同的颜色呢？

994
00:42:27,914 --> 00:42:30,748
I would set the colors, stroke or fill one.
我可以给一个设置颜色，描边或者填充

995
00:42:30,750 --> 00:42:32,149
Set the colors on something else, stroke or
给另一个设置其他的颜色，描边或者

996
00:42:32,151 --> 00:42:32,783
fill the other.
填充

997
00:42:33,719 --> 00:42:34,918
Okay?
明白了么？

998
00:42:34,920 --> 00:42:36,503
Question.
问题

999
00:42:36,504 --> 00:42:38,087
>> If the path isn't closed, what does fill do?
- 如果路径不是闭合的，那怎么去填充呢

1000
00:42:38,089 --> 00:42:39,605
So the question is,
这就是问题

1001
00:42:39,606 --> 00:42:41,122
if the path is not closed, what does fill do?
如果 path 不是闭合的，填充的结果是什么？

1002
00:42:41,125 --> 00:42:43,926
Well, it depends on, I think the winding rule, and,
我想它取决于绕圈规则，以及

1003
00:42:43,928 --> 00:42:45,694
other things about how it draws.
其他如何绘制的一些东西

1004
00:42:45,696 --> 00:42:48,196
But, it will try to fill it in.
但是，它会努力去填充

1005
00:42:48,198 --> 00:42:49,097
Okay. I mean a path could
我的意思是 path 可以

1006
00:42:49,099 --> 00:42:50,931
cross back over itself.
回头和自己相交

1007
00:42:50,933 --> 00:42:52,132
Right? And so filling it
对吗？对这种情况进行填充

1008
00:42:52,134 --> 00:42:54,234
might be hard to understand.
可能很难理解

1009
00:42:54,236 --> 00:42:55,502
And so there are rules for that.
所以有相应的一些规则去处理

1010
00:42:56,604 --> 00:42:58,637
I'll talk about that just briefly in just a second, but
我简要地介绍一下

1011
00:42:58,639 --> 00:43:00,139
it will fill.
它会去填充的

1012
00:43:00,140 --> 00:43:01,640
But there are other things, if you don't close a path then
但是对于别的操作，如果你没有闭合 path

1013
00:43:01,642 --> 00:43:04,042
you can't do things like hit detection, right?
那么你没法做类似碰撞检测等操作，对吗？

1014
00:43:04,044 --> 00:43:05,410
Detecting whether a point is inside it
检测一个点是不是在它里面

1015
00:43:05,412 --> 00:43:07,345
because it's not closed, so there's no inside.
因为没有闭合，所以它没有内部

1016
00:43:10,049 --> 00:43:13,083
So you can, UIBezierPath also has kind of
所以你能，UIBezierPath 有各种

1017
00:43:13,085 --> 00:43:17,653
pre-canned cool shapes like roundedRect, okay,
预制的漂亮图形，比如 roundedRect

1018
00:43:17,655 --> 00:43:20,489
which is a rectangle that the corners are rounded off of, or
它是四个角被磨圆了的矩形

1019
00:43:20,491 --> 00:43:24,960
obviously ovals and circles, it has ways of doing that.
或者干脆是椭圆跟圆形，它有处理这些的方法

1020
00:43:24,962 --> 00:43:28,830
You can also clip to any arbitrary path.
你也可以剪切任意的 path

1021
00:43:28,832 --> 00:43:30,543
So clipping,
所以对于剪切

1022
00:43:30,544 --> 00:43:32,255
hopefully everyone knows what that means.
希望每个人都明白它的意义

1023
00:43:32,256 --> 00:43:33,967
That means, if I set it up, if I have a path, and I say clip.
它意味着如果我设置好了，我有一个 path，我要剪切

1024
00:43:33,970 --> 00:43:37,404
If I say, addClip, then all drawing I do after that
如果我说，addClip，那么在这之后所有的绘图操作

1025
00:43:37,406 --> 00:43:41,941
will only show up if it's inside that path, okay?
只会影响到 path 里面的部分，okay？

1026
00:43:43,178 --> 00:43:44,677
So, for example,
举个例子

1027
00:43:44,678 --> 00:43:46,177
if you were drawing playing card on screen,
如果你正在屏幕上绘制纸牌

1028
00:43:46,180 --> 00:43:49,114
playing cards have little rounded rects, so you might
纸牌有小小的圆角效果，所以你可以

1029
00:43:49,116 --> 00:43:52,484
draw your playing card in a big rectangle, and then clip
把纸牌画在一个大的矩形里面，然后剪切到

1030
00:43:52,486 --> 00:43:56,988
to a rounded rect, so that the corners get cut off, okay.
一个圆角矩阵里，这样四角就修圆了

1031
00:43:56,990 --> 00:43:59,990
That's a cheap simple way to get a rounded rect playing card.
这是一个获得圆角纸牌便宜而又简单的方法

1032
00:44:01,260 --> 00:44:04,127
You can also do hit detection as I mentioned, the hit
你也可以做我提到的碰撞检测，碰撞检测

1033
00:44:04,129 --> 00:44:07,430
detection and the filling depends on the winding rules,
和填充取决于绕圈规则

1034
00:44:07,432 --> 00:44:10,866
and there's this usesEvenOddFillRule, property,
这里有 usesEvenOddFillRule 属性

1035
00:44:10,868 --> 00:44:14,837
which is only yes or no to say which winding rule it uses.
bool 类型，指定了它使用的绕圈规则

1036
00:44:14,839 --> 00:44:16,605
And so people who don't know what that means,
所以不了解它含义的同学们

1037
00:44:16,607 --> 00:44:17,605
don't worry about it.
不用担心

1038
00:44:17,607 --> 00:44:19,207
In fact, don't worry about hit detection or
实际上，不用担心碰撞检测

1039
00:44:19,209 --> 00:44:20,764
any of this stuff,
或者类似的 API

1040
00:44:20,765 --> 00:44:22,320
cuz you're not going to have to do this for your homework.
因为你们的课外作业里不用做这些

1041
00:44:22,321 --> 00:44:23,876
But I just want you to know that BezierPath has a lot of
不过我希望你们能了解 BezierPath 拥有许多

1042
00:44:23,880 --> 00:44:25,946
other stuff besides just line to, line to,
其他东西，不仅仅是画线条

1043
00:44:25,948 --> 00:44:26,680
fill and stroke.
填充和描边

1044
00:44:26,682 --> 00:44:28,615
Okay, it has other stuff.
Okay，它有别的东西

1045
00:44:28,616 --> 00:44:30,549
And when you want to look at UIBezierPath,
当你想要查看 UIBezierPath

1046
00:44:30,552 --> 00:44:32,618
check out its documentation and
可以打开相关文档

1047
00:44:32,620 --> 00:44:34,553
kind of experience it in its full glory.
经历它的各种荣耀

1048
00:44:36,057 --> 00:44:39,491
Okay, let's talk a little bit more about colors because I
Okay，我们再聊一聊颜色

1049
00:44:39,493 --> 00:44:41,626
used a color there, that green color.
因为我在那里用了一种绿色

1050
00:44:41,628 --> 00:44:43,227
UIColor is just an object.
UIColor 是一个对象

1051
00:44:43,229 --> 00:44:45,262
It's really powerful.
它非常强大

1052
00:44:45,264 --> 00:44:46,497
Colors not only can be
它不仅仅是

1053
00:44:46,499 --> 00:44:49,433
standard colors like UIColor.greenColor, but
类似 UIColor.greenColor 的标准颜色

1054
00:44:49,435 --> 00:44:52,736
you can create a color from RGB, red, green, blue, or
你也可以用 RGB，红绿蓝，或者

1055
00:44:52,738 --> 00:44:55,838
HSB, that's hue, saturation, and brightness.
HSB，色调，饱和度，亮度来创建颜色

1056
00:44:55,840 --> 00:44:59,208
You can even set your color to be a pattern, so that when you
你甚至可以把你的颜色设置为一个模式，这样当你

1057
00:44:59,210 --> 00:45:02,311
draw with that color, it actually draws some image.
用那种颜色绘制时，它实际上画出的是图像

1058
00:45:02,313 --> 00:45:02,911
Okay?

1059
00:45:02,913 --> 00:45:05,347
So that's kinda cool.
这个相当酷

1060
00:45:05,349 --> 00:45:10,017
Views have a backgroundColor, which you can set on them.
你可以给 view 设置 backgroundColor

1061
00:45:10,019 --> 00:45:13,353
Also colors can be transparent.
颜色也可以是透明的

1062
00:45:13,355 --> 00:45:14,988
Okay?

1063
00:45:14,989 --> 00:45:16,622
They can be see-through, partially see-through.
他们可以是透明的，半透明的

1064
00:45:16,625 --> 00:45:18,191
This is called alpha.
这叫做 alpha（透明度）

1065
00:45:18,193 --> 00:45:21,027
So alpha is a value between zero and one.
alpha 是一个介于 0 和 1 之间的值

1066
00:45:21,029 --> 00:45:22,461
Zero means fully transparent, so
0 代表完全透明

1067
00:45:22,463 --> 00:45:24,096
you can see completely through it, and
你的视线可以完全穿过去

1068
00:45:24,098 --> 00:45:25,663
it won't even show up on the screen.
它甚至不会出现在屏幕上

1069
00:45:25,665 --> 00:45:27,598
To one, which is fully opaque.
1 代表完全不透明

1070
00:45:27,600 --> 00:45:29,400
It obscures anything behind it.
它遮挡了背后的所有东西

1071
00:45:29,402 --> 00:45:30,868
Anything drawn with this color.
用这种颜色绘制的任何东西

1072
00:45:30,870 --> 00:45:32,903
And you can create a transparent color from
并且你可以通过 colorWithAlphaComponent() 方法来

1073
00:45:32,905 --> 00:45:35,472
another color with this color with alpha component.
生成某种颜色的透明色

1074
00:45:35,474 --> 00:45:37,840
This would create kind of half transparent yellow.
这里创建了一种半透明的黄色

1075
00:45:37,842 --> 00:45:40,943
Color to draw with, and you can draw in your view with
用于绘制，你可以用这些透明颜色

1076
00:45:40,945 --> 00:45:43,045
these transparent colors, okay?
来绘制你的 view，okay？

1077
00:45:43,047 --> 00:45:45,247
Using these BezierPaths.
使用 BezierPaths

1078
00:45:45,249 --> 00:45:48,750
However, if you draw in your view with transparency,
然而，如果你要用透明度来绘制

1079
00:45:48,752 --> 00:45:51,519
you must tell the system that you are going to do that.
你必须告诉系统你要这么做

1080
00:45:51,521 --> 00:45:54,221
And you do that by setting this property on
实现这个，你需要设置

1081
00:45:54,223 --> 00:45:56,623
your UIView called opaque to false.
UIView 的 opaque 属性为 false

1082
00:45:56,625 --> 00:45:58,091
And why is this required?
为什么需要这么做？

1083
00:45:58,093 --> 00:46:00,727
Well, because drawing with transparency is expensive.
因为带透明度的绘制是非常昂贵的

1084
00:46:00,729 --> 00:46:01,961
Because the views behind you
因为你后面的 view

1085
00:46:01,963 --> 00:46:03,829
are gonna start showing through.
会被展示出来

1086
00:46:03,831 --> 00:46:05,197
Okay? So the system has to
Okay？所以系统必须

1087
00:46:05,199 --> 00:46:08,734
blend basically the different views that are overlapping.
把重叠的 view 混合起来绘制

1088
00:46:08,736 --> 00:46:12,237
That's expensive in terms of graphics power.
这在图像处理能力上非常昂贵

1089
00:46:12,239 --> 00:46:14,772
And so it doesn't wanna do that if it doesn't have to.
所以如无必要别这么干

1090
00:46:14,774 --> 00:46:16,374
If it can just draw the bit.
假设它在绘制某个点

1091
00:46:16,376 --> 00:46:17,875
If you don't set this to false and
如果你没有把这个设置为 false

1092
00:46:17,877 --> 00:46:20,410
you try drawing transparently, it's not gonna work.
并且你还要画成透明的，那不会成功的

1093
00:46:20,412 --> 00:46:22,479
Okay?

1094
00:46:22,480 --> 00:46:24,547
Cuz it's not gonna blend with the things behind.
因为它不会把后面的东西混合进来

1095
00:46:24,549 --> 00:46:28,918
You can make your entire view transparent.
你可以把整个 view 设置成透明的

1096
00:46:28,920 --> 00:46:29,985
Okay?

1097
00:46:29,987 --> 00:46:31,386
It has its own property alpha,
它有自己的 alpha 属性

1098
00:46:31,388 --> 00:46:33,722
which you can set to anywhere between zero and one.
你可以设置 0 到 1 之间的任意值

1099
00:46:33,724 --> 00:46:34,906
It'll make your view,
它会使你的 view

1100
00:46:34,907 --> 00:46:36,089
everything you draw in the view will be
你在 view 上绘制的所有东西

1101
00:46:37,193 --> 00:46:39,460
however much transparent you want it to be.
带上你想要的任意透明度

1102
00:46:39,462 --> 00:46:41,194
Okay?

1103
00:46:41,196 --> 00:46:45,331
What happens when views overlap and have transparency?
当带有透明度的 view 互相重叠时会发生什么？

1104
00:46:45,333 --> 00:46:46,832
They're blended as I said,
它们会像我说的那样混合

1105
00:46:46,834 --> 00:46:49,268
remember that the subview's order matters.
记住 subview 的顺序有影响

1106
00:46:49,270 --> 00:46:51,636
Okay? The thing that is first in
Okay？subview array 里的第一个

1107
00:46:51,638 --> 00:46:54,439
the subviews array is in the back.
出现在最后面

1108
00:46:54,441 --> 00:46:56,808
And everything down the array is in front.
array 里剩下的 view 按照顺序出现在前面

1109
00:46:56,810 --> 00:46:59,276
So, when the transparency happens,
所以，当透明度产生时

1110
00:46:59,278 --> 00:47:01,979
that's the order it's gonna happen in.
这就是将要发生的顺序

1111
00:47:01,981 --> 00:47:05,315
You can completely hide a view by sending it hidden equal to
你可以完全隐藏一个 view，只要把它的 hidden 设置为

1112
00:47:05,317 --> 00:47:08,718
true, and this is surprisingly common to just hide a view,
true，这种隐藏一个 view 的做法非常普遍

1113
00:47:08,720 --> 00:47:11,854
and maybe it appears when a certain condition is true on
当某个条件成立它可以出现在屏幕上

1114
00:47:11,856 --> 00:47:14,490
screen, or whatever you can set up this view in
或者在你的 StoryBoard 里创建这个 view

1115
00:47:14,492 --> 00:47:17,526
your StoryBoard and then set it to hidden, to true.
然后把 hidden 设置为 true

1116
00:47:17,528 --> 00:47:19,161
And so it comes up, it's not there.
所以它出来的时候，你看不到

1117
00:47:19,163 --> 00:47:22,230
And then in code you say hidden equals false, boom,
然后你在代码中设置 hidden 为 false，轰隆

1118
00:47:22,232 --> 00:47:23,431
it appears, okay?
出现了，okay？

1119
00:47:23,433 --> 00:47:25,466
So that's a way to, completely hide the view.
所以这是个彻底隐藏 view 的方法

1120
00:47:25,468 --> 00:47:26,900
A hidden view not only doesn't draw,
隐藏的 view 不仅不会被绘制

1121
00:47:26,902 --> 00:47:28,635
it doesn't receive any touch events either.
也不会接受任何触控事件

1122
00:47:28,637 --> 00:47:30,103
But it's still in the view hierarchy.
不过它依旧存在于 view 的层级关系中

1123
00:47:30,105 --> 00:47:31,304
It's kinda there waiting.
有点像在那等待

1124
00:47:31,306 --> 00:47:33,139
Okay?

1125
00:47:33,141 --> 00:47:34,807
All right, drawing text.
好的，绘制文本

1126
00:47:34,809 --> 00:47:37,476
So, usually you draw text on screen with a UILabel.
通常你们用 UILabel 在屏幕上绘制文本

1127
00:47:37,478 --> 00:47:40,211
That's what you did with your display, et cetera.
这就是你用你的显示做的事，等等

1128
00:47:40,213 --> 00:47:43,548
But you might wanna draw in your drawRect and
不过你可能想要在 drawRect 上绘制

1129
00:47:43,550 --> 00:47:45,916
you do that with this class called NSAttributedString,
你用 NSAttributedString 来干这个

1130
00:47:45,918 --> 00:47:47,685
which I'm really not gonna cover.
这部分我不准备讲解

1131
00:47:47,687 --> 00:47:49,503
You wanna look at
你可以查看

1132
00:47:49,504 --> 00:47:51,320
its documentation if you wanna draw a text.
它的文档，如果你想要绘制文本

1133
00:47:51,323 --> 00:47:53,890
I'm not gonna do a demo of NSAttributedString, but
我不会给出 NSAttributedString 的演示，不过

1134
00:47:53,892 --> 00:47:55,058
I'm gonna give you some code for
我会给你们一些代码作为

1135
00:47:55,060 --> 00:47:56,325
your assignment next week, and I'm
下周的作业

1136
00:47:56,327 --> 00:47:59,361
gonna use NSAttributedString in the code I'm giving you,
我会在给你们的代码里使用 NSAttributedString

1137
00:47:59,363 --> 00:48:01,630
so you'll be able to see an example of how it's used.
所以你们能看到如何使用它的例子

1138
00:48:01,632 --> 00:48:03,865
But basically NSAttributedString is
但是基本上 NSAttributedString

1139
00:48:03,867 --> 00:48:05,333
a bunch of characters and
就是一串字符和

1140
00:48:05,335 --> 00:48:07,668
some attributes on those characters.
设置在这些字符上的一些 attributes（属性）

1141
00:48:07,670 --> 00:48:11,805
Now attributed String has a couple of interesting things
现在 AttributedString 有一些有趣的

1142
00:48:11,807 --> 00:48:12,572
about it.
特点

1143
00:48:12,574 --> 00:48:13,740
It's easy to use.
它易于使用

1144
00:48:13,742 --> 00:48:16,075
You can just create it, pass it a String, and
你可以创建它，传入一个 String

1145
00:48:16,077 --> 00:48:19,044
then say drawAtPoint, and that will draw the String with
然后调用 drawAtPoint，然后 String 就画出来了

1146
00:48:19,046 --> 00:48:21,580
its point, its upper left corner at that point.
参数指定了它的左上角位置

1147
00:48:21,582 --> 00:48:24,215
And you can even find out how big it's gonna be by asking it
你可以查看它将要占用的大小

1148
00:48:24,217 --> 00:48:25,850
the size of this attribute String.
调用 size 就行

1149
00:48:25,852 --> 00:48:28,285
So it's pretty easy to use in that way.
这么做非常容易

1150
00:48:28,287 --> 00:48:30,688
Mutability is not done with var and
var 跟 let 无法为 NSAttributedString

1151
00:48:30,690 --> 00:48:32,756
let for NSAttributedString.
带来可变性

1152
00:48:32,758 --> 00:48:33,656
There's a different class
有另一种 class

1153
00:48:33,658 --> 00:48:36,325
called NSMutableAttributedString.
叫做 NSMutableAttributedString

1154
00:48:36,327 --> 00:48:37,827
Okay? And why would you
Okay？为什么你们

1155
00:48:37,829 --> 00:48:40,262
want a MutableAttributedString?
想要一个 MutableAttributedString 呢？

1156
00:48:40,264 --> 00:48:41,830
Well because these Strings,
因为这些 String

1157
00:48:41,832 --> 00:48:44,265
what makes an AttributedString attributed,
AttributedString 之所以是 AttributedString

1158
00:48:44,267 --> 00:48:47,502
is you can put attributes on the characters in this String.
是因为你可以在 String 的字符上面设置 attributes

1159
00:48:47,504 --> 00:48:49,770
And so a MutableAttributedString,
所以对于 MutableAttributedString

1160
00:48:49,772 --> 00:48:51,538
you can set the attributes.
你可以设置 attributes

1161
00:48:51,540 --> 00:48:54,007
You can get the String out as an NSString,
你可以把里面的文本导出为 NSString

1162
00:48:54,009 --> 00:48:57,210
using the string property on NSAttributedString but
用 NSAttributedString 的 string 属性

1163
00:48:57,212 --> 00:48:59,946
NSAttributedString itself is not a String.
但是 NSAttributedString 本身不是 String

1164
00:48:59,948 --> 00:49:02,048
It's not like a subclass of NSString or anything.
它不是 NSString 的子类或者别的

1165
00:49:02,050 --> 00:49:03,349
It's its own thing.
它属于它自己

1166
00:49:03,351 --> 00:49:05,434
So you set
所以你们

1167
00:49:05,435 --> 00:49:07,518
these attributes with functions like setAttributes.
用 setAttributes 等函数设置 attributes

1168
00:49:07,521 --> 00:49:09,387
It takes a Dictionary of attributes.
它使用一个 Dictionary 类型的 attributes

1169
00:49:09,389 --> 00:49:11,189
I'll talk to you about what the keys and
我稍后介绍它的各种 keys

1170
00:49:11,191 --> 00:49:12,590
values are in a second.
跟 values

1171
00:49:12,592 --> 00:49:15,143
And then a range.
还有 range（范围）

1172
00:49:15,144 --> 00:49:17,695
That's an NSRange right there by the way, not a Swift Range.
注意是 NSRange，不是 Swift Range

1173
00:49:17,697 --> 00:49:20,497
And the indexing into these Strings is
这些 Strings 的索引

1174
00:49:20,499 --> 00:49:22,966
the old style NSString version.
是 NSString 版的古老风格

1175
00:49:22,968 --> 00:49:24,967
It's not the string.index stuff we
它不是 string.index 这样

1176
00:49:24,969 --> 00:49:26,335
talked about last time.
上次我们讲过了

1177
00:49:26,337 --> 00:49:29,471
It's literally which Unicode character are you
字面上的意思是在哪个你关注的

1178
00:49:29,473 --> 00:49:32,107
talking about setting an attribute at?
的 Unicode 文字上面设置一个 attribute？

1179
00:49:32,109 --> 00:49:33,792
Okay?

1180
00:49:33,793 --> 00:49:35,476
So, this Dictionary has a bunch of attributes.
所以这个 Dictionary 有一串 attributes

1181
00:49:35,479 --> 00:49:37,178
The attributes can be things like,
attributes 可以是类似

1182
00:49:37,180 --> 00:49:39,280
set the foreground color of this text.
设置文本的前景色

1183
00:49:39,282 --> 00:49:39,947
Okay?

1184
00:49:39,949 --> 00:49:41,648
Set the stroke width.
可以是设置描边的宽度

1185
00:49:41,650 --> 00:49:43,283
Okay? Because remember,
Okay？记住

1186
00:49:43,285 --> 00:49:44,484
text is just paths.
文本就是一些 paths

1187
00:49:44,486 --> 00:49:47,153
You can stroke them and set the width or the font,
你可以对它们描边，而且可以指定宽度或者字体

1188
00:49:47,155 --> 00:49:49,421
is a really important one to be able to say.
这是值得一提的重要能力

1189
00:49:49,423 --> 00:49:52,991
Set this text to have this particular font, okay?
（attributes 可以是）对文本使用特定字体，okay？

1190
00:49:52,993 --> 00:49:55,827
And so you just set a Dictionary that has
这样你只要设置一个

1191
00:49:55,829 --> 00:49:59,964
the key NSFontAttribute and the value would be a UIFont.
key 为 NSFontAttribute，value 为 UIFont 的一个 Dictionary

1192
00:49:59,966 --> 00:50:01,799
Okay?

1193
00:50:01,800 --> 00:50:03,633
Now let's talk about UIFonts, briefly.
现在我们简要讨论一下 UIFonts

1194
00:50:03,636 --> 00:50:07,270
Fonts in iOS 7 and later, including iOS 8,
Fonts 从 iOS 7 开始，包括 iOS 8

1195
00:50:07,272 --> 00:50:09,439
are very important to get right, okay?
正确使用非常重要，okay？

1196
00:50:09,441 --> 00:50:10,640
Look at these screenshots.
请看这些截图

1197
00:50:10,642 --> 00:50:12,908
Look how important the fonts are.
看下这些字体有多么重要

1198
00:50:12,910 --> 00:50:14,743
Okay? They're critical,
Okay？它们是

1199
00:50:14,745 --> 00:50:16,745
to making the UI look good.
创建漂亮 UI 的关键

1200
00:50:16,747 --> 00:50:18,497
Okay?

1201
00:50:18,498 --> 00:50:20,248
So, you've got to get the right fonts in your app.
所以你需要让你的 app 拥有一个合适的字体

1202
00:50:20,250 --> 00:50:22,350
And where do you get the right fonts?
那么怎么能够使字体合适呢？

1203
00:50:22,352 --> 00:50:24,752
Well, the number one place to get a font,
使这个字体合适的，

1204
00:50:24,754 --> 00:50:28,489
the right place 99% of the time, is this class function
百分之九十九都能使你的字体好看的，是这个在 UIFont 这个类

1205
00:50:28,491 --> 00:50:32,826
in UIFont called preferredFontForTextStyle, okay?
里面的一个类函数，叫 preferredFontForTextStyle

1206
00:50:32,828 --> 00:50:36,696
The text style is something like headline, or
字体样式是类似标题，或者

1207
00:50:36,698 --> 00:50:38,548
a body, okay?
正文这些东西

1208
00:50:38,549 --> 00:50:40,399
The body would be like the main content that your user is
正文就是你展现给用户看的主要的

1209
00:50:40,401 --> 00:50:42,051
looking at.
内容

1210
00:50:42,052 --> 00:50:43,702
Headline might be like a title at the top.
标题一般就是顶部的这个标题

1211
00:50:43,704 --> 00:50:46,171
Footnote might be a small little thing mentioned at
注脚是在底部的一行小小的字，

1212
00:50:46,173 --> 00:50:47,923
the bottom, okay?
好吧？

1213
00:50:47,924 --> 00:50:49,674
And there's a whole bunch more of these text styles.
这里还有很多很多这种字体样式

1214
00:50:49,676 --> 00:50:51,559
And so, you're gonna ask
那么你可能会问，

1215
00:50:51,560 --> 00:50:53,443
the assistant give me the preferred font for that style.
这个字体助手给我了一个对应这种样式的推荐的字体

1216
00:50:53,446 --> 00:50:57,664
The font includes a size. Okay?
这个字体包含了字体大小

1218
00:50:57,665 --> 00:50:59,815
UIFont include the size, as well as the face.
UIFont 包括了其大小以及它的样子

1219
00:50:59,818 --> 00:51:02,852
And users can go into their settings on their phone and
用户可能会去设置里面改变了一些字体相关的设置，

1220
00:51:02,854 --> 00:51:05,321
change and say I can't see it anymore.
比如老花眼了看不清楚那些字

1221
00:51:05,323 --> 00:51:06,706
Kinda like me.
像我一样

1222
00:51:06,707 --> 00:51:08,657
And they make their fonts bigger. Okay?
那么他们设置大一点的字体

1224
00:51:08,659 --> 00:51:09,491
And so this would
那这个推荐字体将会

1225
00:51:09,493 --> 00:51:12,027
automatically get that new size.
自动地获取到新的字体大小

1226
00:51:12,029 --> 00:51:13,261
Okay? So that's why you
所以你

1227
00:51:13,263 --> 00:51:15,162
always wanna use preferred font any
用这个推荐的字体总是好的，

1228
00:51:15,164 --> 00:51:17,931
time you're displaying any user content, okay?
在任何时候都是，尤其是你要展示给用户看的时候

1229
00:51:17,933 --> 00:51:20,767
Now, it is possible to create fonts where you say,
你当然可以自己创建一个字体，

1230
00:51:20,769 --> 00:51:22,702
give me Arial 15 narrow or what.
比如说，给我一个 15 号大小的窄体 Arial 字体

1231
00:51:22,704 --> 00:51:25,071
It is possible, but you really shouldn't be doing that.
你可以这么做，但是你不该这么做

1232
00:51:25,073 --> 00:51:27,006
You should be using this preferred font for style.
你还是乖乖地用推荐的字体

1233
00:51:27,008 --> 00:51:28,941
There's also a system font.
这里也有系统默认字体

1234
00:51:28,943 --> 00:51:31,376
This is something that appears on buttons and
比如出现在按钮上的，或者

1235
00:51:31,378 --> 00:51:35,113
in things like Segmented Controls, things like that.
出现在 Segmented Control （UI控件的一种）上的

1236
00:51:35,115 --> 00:51:39,316
You never wanna use only the system fonts for user content.
你永远不会只想用系统设置的是吧？

1237
00:51:39,318 --> 00:51:42,719
User content you wanna use the preferred fonts. Okay?
你更希望用推荐的字体来显示你的内容给用户看

1239
00:51:44,155 --> 00:51:45,821
So yeah, other ways to get fonts, ignore them.
啊这里是些其他获得字体的方法，忽略它们

1240
00:51:45,823 --> 00:51:48,090
I'm not gonna talk about it, okay?
在这里我不会讲它

1241
00:51:48,092 --> 00:51:50,425
All right, how about drawing images?
好的，那么怎么显示图像呢？

1242
00:51:50,427 --> 00:51:52,227
How do you do that?
你会怎么做？

1243
00:51:52,228 --> 00:51:54,028
Well there is a UILabel for
我们有个专门负责图像的 "UILabel"

1244
00:51:54,031 --> 00:51:56,264
images, it's called UIImageView.
叫 UIImageView

1245
00:51:56,266 --> 00:51:58,065
And you can use that to put an image on screen, but
你可以用这个类把图像显示到屏幕上，但是呢，

1246
00:51:58,067 --> 00:52:01,368
you might wanna draw an image, in your drawRect as well.
你可能希望把这个图像丢到你的 drawRect 里面

1247
00:52:01,370 --> 00:52:04,338
And usually you create an image by name, from that
一般来说你会以名字来创建这个图像，

1248
00:52:04,340 --> 00:52:07,674
Images.xcassets thing that we moved out of the way real
从 Images.xcassets 里面拿出来，

1249
00:52:07,676 --> 00:52:10,076
quick right at the beginning of our very first demo.
一会第一个演示一开始就会给大家瞅瞅

1250
00:52:10,078 --> 00:52:12,345
And if you click on that, it's pretty self-explanatory.
如果你点击它，故名思议

1251
00:52:12,347 --> 00:52:13,679
You can drag images.
你可以拖动图像

1252
00:52:13,681 --> 00:52:16,081
You can have different images of different resolutions for
你可以根据不同的分辨率，不同的设备，

1253
00:52:16,083 --> 00:52:17,149
different devices.
设置不同尺寸的图像

1254
00:52:17,150 --> 00:52:18,216
It's really pretty powerful.
总之就是很强大

1255
00:52:18,218 --> 00:52:20,200
That's usually how you create an image.
这就是一般创建图像的步骤

1256
00:52:20,201 --> 00:52:23,120
By name and dragging into the Images.xcassets.
通过图像的名字，拖进 Images.xcassets 里面

1257
00:52:23,122 --> 00:52:25,389
You can create it in other ways from the file system,
你也可以用其他方法从系统文件中创建出来，

1258
00:52:25,391 --> 00:52:27,991
which we haven't talked about, or even with drawing, but
我们还没讲到这些，包括怎么画图像，

1259
00:52:27,993 --> 00:52:29,826
we're not gonna talk about that either.
我们也不会讲这些

1260
00:52:29,828 --> 00:52:33,429
Once you have the UIImage, you can draw it by just sending it
当你有了这个 UIImage，你可以发送一个消息去显示它，

1261
00:52:33,431 --> 00:52:35,231
the message, drawAtPoint.
这个函数是 drawAtPoint

1262
00:52:35,233 --> 00:52:38,133
And it will draw in its normal size with that point as
然后这个函数就会把正常尺寸的的图像在左上角的那个点上

1263
00:52:38,135 --> 00:52:39,634
it's upper left.
显示出来

1264
00:52:39,636 --> 00:52:41,403
You can also say drawInRect, and
你也可以用 drawInRect 这个函数，

1265
00:52:41,405 --> 00:52:44,605
it'll scale to fit that rect, either bigger or smaller, or
它会缩放图像让其适应这个长方形区域，可以放大或者缩小，或者

1266
00:52:44,607 --> 00:52:47,608
you can draw a pattern in rect it'll tile it repeatedly to
你可以在这个长方形区域里面画一个图案，它会不断地重复平铺，

1267
00:52:47,610 --> 00:52:50,044
fill the rect. Okay?
铺满整个长方形区域

1269
00:52:50,045 --> 00:52:51,645
So really easy to draw images inside your drawRect.
在你的 drawRect 里面显示图像真的是很简单

1270
00:52:51,647 --> 00:52:54,547
And the last thing I wanna talk about is,
那么关于这个我想补充的是，

1271
00:52:54,549 --> 00:52:58,484
what happens when your bounds changes in your UIView?
如果你的 UIView 的边框变了咋办？

1272
00:52:58,486 --> 00:53:00,719
Like the, the user rotates the phone.
比如说用户旋转了他的手机

1273
00:53:00,721 --> 00:53:02,721
Now your bounds are wide and
现在你的边框变得胖矮胖矮的，

1274
00:53:02,723 --> 00:53:06,257
not very tall, instead of tall and not so wide.
不是以前那样高瘦高瘦的

1275
00:53:07,427 --> 00:53:09,210
You might think,
你也许会想，

1276
00:53:09,211 --> 00:53:10,994
oh my drawRect's gonna get called, and I'm gonna redraw.
噢我需要再调用一次 drawRect，然后就会重新适应

1277
00:53:10,996 --> 00:53:12,529
But no, that does not happen.
但这是不可能的

1278
00:53:12,531 --> 00:53:16,666
Instead, the bits that were on screen get stretched.
相反，在屏幕中的图像会被拉扁

1280
00:53:16,668 --> 00:53:20,035
Okay? So, usually that's not what you want.
所以一般来说得不到你想要的效果

1281
00:53:20,038 --> 00:53:22,772
You can and
你将会

1282
00:53:22,773 --> 00:53:25,507
result in a very grainy, kind of bit stretching of your UI.
使其变成马赛克那样，有点强行拉大了图像

1283
00:53:25,509 --> 00:53:27,426
But that is the default,
但这是默认设置

1284
00:53:27,427 --> 00:53:29,344
is the bit stretching because it's higher performance.
默认就会将图像拉伸，因为其有更好的性能

1285
00:53:29,346 --> 00:53:32,914
Now, you control though, you can control what happens to
其实呢，当边界改变了，你可以控制

1286
00:53:32,916 --> 00:53:35,049
your view when the bounds change,
你的 view 的变化，

1287
00:53:35,051 --> 00:53:38,052
with this property in view called contentMode.
用 view 中的一个叫 contentMode 的属性就能做到

1288
00:53:38,054 --> 00:53:40,821
And here are some of the contentModes you can set.
这里有些你可以修改的 contentMode，

1289
00:53:40,823 --> 00:53:43,323
There's left, right, top, bottom, et cetera.
这里有上下左右等等

1290
00:53:43,325 --> 00:53:46,592
All these ones basically don't change the bits.
这里的这些修改基本上不会像刚才那样的改变

1291
00:53:46,594 --> 00:53:48,461
They don't re-draw, but
它们不会重新显示图片，但是

1292
00:53:48,462 --> 00:53:50,329
they just move your entire view to the left edge,
它们只是让你的 view 整体移动到新的边界的左边，右边，

1293
00:53:50,331 --> 00:53:53,432
right edge, top, or bottom of the new bounds.
上边或者下边

1294
00:53:53,434 --> 00:53:54,933
These are kinda strange ones.
这是些奇怪的属性，

1295
00:53:54,935 --> 00:53:56,801
You probably don't need that very often.
一般来说你应该不会用到

1296
00:53:56,803 --> 00:53:58,169
Then there's the scaling of the bits.
这里是些缩放，

1297
00:53:58,171 --> 00:54:00,604
So here's the default, ScaleToFill.
默认的是 ScaleToFill

1298
00:54:00,606 --> 00:54:02,840
'Kay, we'll scale the bits to fill the new bounds, but
我们会缩放图像去填满新的边界，但是

1299
00:54:02,842 --> 00:54:05,842
you can also fill or fit the bounds and
你仍可以填满或者适应边界，

1300
00:54:05,844 --> 00:54:07,210
keep it aspect ratio.
而且保存图像原来的长宽比例

1301
00:54:07,212 --> 00:54:09,012
So that won't stretch your bits.
这些就不会再拉伸你的图像了

1302
00:54:09,014 --> 00:54:10,413
It'll still scale them, but
它们可以缩放，但是

1303
00:54:10,415 --> 00:54:13,582
it'll scale them with your aspect ratio maintained, or
是以原来的长宽比例来缩放的，或者

1304
00:54:13,584 --> 00:54:17,219
you can have the wonderest Redraw, 'kay?
你也可以用你最想用的 redraw

1305
00:54:17,221 --> 00:54:19,421
This is the one you wanna set that says,
你心想：我设成这样，

1306
00:54:19,423 --> 00:54:22,690
when my bounds change, call my drawRect again.
当我的边界发生了变化，再次调用我的 drawRect 函数

1308
00:54:22,692 --> 00:54:25,392
Okay? With the new bounds.
有了新的边界

1309
00:54:25,394 --> 00:54:26,793
So you're gonna want that quite often.
你将会常常需要用到它

1310
00:54:26,795 --> 00:54:29,129
I'll show you that in the demo today.
我会在今天的展示中做给你们看

1311
00:54:29,131 --> 00:54:30,630
All right, so let's get right to this demo.
好的，那我们开始展示吧

1312
00:54:31,699 --> 00:54:34,767
Today, it's gonna be a little tight to do this in 20 minutes
今天这个展示的时间有点紧，因为还剩20分钟了，

1313
00:54:34,769 --> 00:54:37,002
but, cuz we're gonna cover a lot of stuff but
因为我们今天讲了好多东西，但是

1314
00:54:37,004 --> 00:54:38,036
I think we can do it.
我觉得我们应该够时间的

1315
00:54:38,038 --> 00:54:42,273
We're going to start by creating a new project.
我们开始创建一个新的项目

1316
00:54:42,275 --> 00:54:43,841
So I'm just going to file a new project,
点击 file -> new -> project，

1317
00:54:43,843 --> 00:54:44,775
this is brand new.
全新的一个项目

1318
00:54:44,776 --> 00:54:45,708
Okay? We're going away from
我们将暂时把我们之前的

1319
00:54:45,711 --> 00:54:46,676
the Calculator here.
计算器放一边

1320
00:54:46,678 --> 00:54:47,944
And as always we're gonna be
就像之前一样我们将

1321
00:54:47,946 --> 00:54:50,346
using the single view application thing right here.
用这里的 Single View Application

1322
00:54:50,348 --> 00:54:52,781
I'm gonna call this project Happiness,
我将这个项目命名为 Happiness，

1323
00:54:52,783 --> 00:54:55,684
because we're gonna draw a face, a smiley face.
因为我们将会展示一个笑脸，

1324
00:54:55,686 --> 00:54:56,851
Okay? And it's gonna be
它将能够

1325
00:54:56,853 --> 00:54:59,654
able to smile or frown, depending on how happy it is.
微笑或者皱眉，这取决于它有多开心

1327
00:54:59,656 --> 00:55:02,489
Okay? So that's why we're gonna call this Happiness.
所以我们命名为 Happiness

1328
00:55:02,492 --> 00:55:04,992
I'm gonna put it in the same place I put my Calculator,
我把它放在我的 Calculator 项目的位置，

1329
00:55:04,994 --> 00:55:07,094
which is my home directory developer there.
也就是我的 home 目录下的 developer 里面

1330
00:55:07,096 --> 00:55:08,428
Here it is.
就是这里

1331
00:55:08,430 --> 00:55:12,031
As before I'm gonna move this AppDelegate out of the way.
像之前一样我将会把这个 AppDelegate 放开一边

1332
00:55:12,033 --> 00:55:14,433
I'm gonna move, actually let's take a look at image.xcassets.
我将会移...等等我们先看看这个 image.xcassets

1333
00:55:14,435 --> 00:55:16,669
So here's the appicon slots.
这里是 Appicon（应用图标）的空槽

1334
00:55:16,671 --> 00:55:18,403
You can see that for any given image,
你可以看到，对于不同的图像，

1335
00:55:18,405 --> 00:55:21,306
like the appicon, there's lots of different resolutions,
像这个 Appicon，它有很多不同的分辨率

1336
00:55:21,308 --> 00:55:24,876
depending on the devices that you can provide. Okay?
取决于你提供的设备

1338
00:55:24,877 --> 00:55:26,210
You don't have to provide all the different resolutions,
你不必提供所有的分辨率，

1339
00:55:26,212 --> 00:55:27,945
it will interpolate but you can do it.
它会自己添加，但你也可以都提供

1340
00:55:27,947 --> 00:55:31,848
So you just drag an image into here, and now you can get it
那么先把这个图像拖进来，然后你就能通过图片名来指定了，

1341
00:55:31,850 --> 00:55:34,951
by name with that UIImage named function.
用 UIImage 那个函数

1342
00:55:34,953 --> 00:55:36,169
So we'll get that out of there.
我们还是先把它放出去

1343
00:55:36,170 --> 00:55:37,386
We don't want the launch screen either.
我们也不想要 LaunchScreen

1344
00:55:37,389 --> 00:55:38,955
So here we are.
就先这样

1345
00:55:38,956 --> 00:55:40,522
I'm gonna show you something fun here too.
我将给你们展示一些有趣的东西

1346
00:55:40,525 --> 00:55:43,158
Here is my StoryBoard.
这是我的 StoryBoard

1347
00:55:43,160 --> 00:55:46,028
I'm gonna show you how to add a new View Controller to
我将给你们展示一下怎么把一个新的 View Controller 添加到

1348
00:55:46,030 --> 00:55:47,062
your StoryBoard.
你的 StoryBoard 中

1349
00:55:47,064 --> 00:55:48,696
And in fact, I'm gonna delete this one.
事实上我将删除这一个

1350
00:55:48,698 --> 00:55:50,064
So, you see this one right here I've selected?
看到我选择的这个了吗？

1351
00:55:50,066 --> 00:55:50,964
I'm just deleting it.
然后我删除它

1352
00:55:50,966 --> 00:55:52,866
It's gone. I'm gonna delete its
删掉了同时我也将删除它的

1353
00:55:52,868 --> 00:55:54,735
code as well.
代码

1354
00:55:54,736 --> 00:55:56,603
I'm gonna go here, and just delete, move it to the trash.
我点击这里，然后删除，将其移除到垃圾箱

1355
00:55:56,605 --> 00:55:59,339
Now I have a StoryBoard with nothing in it, and
现在我有一个啥都没有的空 StoryBoard，

1356
00:55:59,341 --> 00:56:01,040
I've no View Controllers.
里面也没有 View Controllers

1357
00:56:01,042 --> 00:56:02,542
Okay?

1358
00:56:02,543 --> 00:56:04,043
So, how do I add a View Controller?
我怎么添加一个 View Controller？

1359
00:56:04,045 --> 00:56:06,144
You go over here to your Object Pallet.
你点这个 Object Pallet（Xcode 最右下角）

1360
00:56:06,146 --> 00:56:08,313
The very first thing is a View Controller.
这里的第一个就是 View Controller

1361
00:56:08,315 --> 00:56:09,981
And you just drag it out, and boom.
然后你拖出来，哗的一下，

1362
00:56:09,983 --> 00:56:10,781
You've got one.
你得到了一个 View Controller

1363
00:56:11,917 --> 00:56:13,550
Now, the class.
现在，它的类，

1364
00:56:13,552 --> 00:56:15,318
What class is this going to be though?
它的类是什么呢？

1365
00:56:15,320 --> 00:56:17,720
This is gonna be Generic UIViewController, so
它是一个普通的的 UIViewController

1366
00:56:17,722 --> 00:56:19,121
it's pretty useless.
所以这并没什么用

1367
00:56:19,123 --> 00:56:20,823
Okay? You can't add any outlets, or
你不能用它来添加 outlet （IBOutlet）

1368
00:56:20,825 --> 00:56:23,525
have any actions because it's not a subclass of UIViewController,
也不能添加任何 action，因为它不是 UIViewController 的子类，

1369
00:56:23,527 --> 00:56:26,628
so you can't put any of that implementation in.
所以你不能在里面放任何实现功能的代码

1370
00:56:26,630 --> 00:56:30,564
So, we're gonna create a new subclass of UIViewController.
因此我们需要创建一个 UIViewController 的子类

1371
00:56:30,566 --> 00:56:31,665
So let me show you how to do that.
让我来给你们展示一下

1372
00:56:31,667 --> 00:56:33,834
You say New > File.
新建一个文件， New -> File

1373
00:56:33,836 --> 00:56:35,869
And last time we went to New > File,
上回我们这么做，

1374
00:56:35,871 --> 00:56:38,671
we said Swift file to make the CalculatorBrain.
是新建 Swift 文件来创建 CalculatorBrain

1375
00:56:38,673 --> 00:56:41,574
But now we're gonna go over here to Cocoa Touch Class,
但是现在我们选择这个 Cocoa Touch Class，

1376
00:56:41,576 --> 00:56:45,661
which we do anytime we wanna create a subclass of an iOS class.
每当我们想要新建 iOS 的子类的时候，我们都会选择它

1378
00:56:45,662 --> 00:56:47,212
And here I'm creating a subclass of UIViewController.
这里我要创建一个 UIViewController 的子类，

1379
00:56:47,214 --> 00:56:48,346
I need this.
那么我就需要它

1380
00:56:48,348 --> 00:56:50,381
So I'm gonna click on that.
点击一下

1381
00:56:50,383 --> 00:56:52,583
Here's where I pick what I want it to be a subclass of.
在这里我选择我想要继承的类

1382
00:56:52,585 --> 00:56:53,884
You can see there's a lot of things in here.
你可以看到这里有很多东西

1383
00:56:53,886 --> 00:56:56,119
I'm gonna say I want a View Controller.
我想要一个 View Controller

1384
00:56:56,121 --> 00:56:58,021
It wants to call it ViewController by default.
它默认名字就是 ViewController

1385
00:56:58,023 --> 00:56:59,889
We don't even like that for
我们甚至在我们的 Calculator 中

1386
00:56:59,891 --> 00:57:02,291
the Calculator, let alone this.
都不这样叫，更别说这个了

1387
00:57:02,293 --> 00:57:06,128
So I'm gonna call this my HappinessViewController.
我想叫它 HappinessViewController

1389
00:57:06,130 --> 00:57:08,997
Okay? So it creates that.
这样就创建好了

1390
00:57:08,999 --> 00:57:11,599
Put it in the same place all my other Swift files are.
把它放在我其他的 Swift 文件那里

1391
00:57:11,601 --> 00:57:12,800
Here it is.
搞定了

1392
00:57:12,802 --> 00:57:14,118
HappinessViewController.

1393
00:57:14,119 --> 00:57:16,470
Again, I'm gonna get rid of this code.Okay?
再一次，我将把这些代码删掉

1395
00:57:16,472 --> 00:57:18,972
Just to make things a little clearer.
让它看起来更简洁

1396
00:57:18,974 --> 00:57:20,039
So here's my HappinessViewController.
这个就是我的 HappinessViewController

1397
00:57:20,041 --> 00:57:22,675
It's just like the View Controller you had,
就像是之前的 View Controller 一样，

1398
00:57:22,677 --> 00:57:26,278
that was called ViewController in your Calculator.
我们在 Calculator 叫 ViewController

1399
00:57:26,280 --> 00:57:28,013
It was called HappinessViewController.
这里呢我们叫它 HappinessViewController

1400
00:57:28,015 --> 00:57:29,481
But this guy right here,
但是这里的这个家伙，

1401
00:57:29,483 --> 00:57:31,783
is still playing old View Controller.
还是以前的 View Controller

1402
00:57:31,785 --> 00:57:32,917
How do I know that?
我怎么能知道呢？

1403
00:57:32,919 --> 00:57:34,752
Well, it's this magic right here.
神奇的东西在这里，

1404
00:57:34,754 --> 00:57:36,787
You see this Identity Inspector?
你看到这个 Identity Inspector 了吗？

1405
00:57:36,789 --> 00:57:38,521
Okay. You can see the class of
你可以看到被选择的东西的类，

1406
00:57:38,523 --> 00:57:41,791
this selected thing here, in this UIView Controller.
在这里是 UIViewController

1407
00:57:41,793 --> 00:57:43,793
And I don't want it to be UIViewController.
我不想让其是 UIViewController

1408
00:57:43,795 --> 00:57:46,462
I want it to be HappinessViewController.
我想让它是 HappinessViewController

1409
00:57:46,464 --> 00:57:49,264
So, very important to understand that in
明白这里很重要，在 StoryBoard 里，

1410
00:57:49,266 --> 00:57:52,033
StoryBoards, everything is linked up to
所有东西都用名字和你的代码

1411
00:57:52,035 --> 00:57:53,334
your code by name.
相连接

1412
00:57:53,336 --> 00:57:54,902
Only by the name.
只用名字

1413
00:57:54,904 --> 00:57:56,603
That is the only thing that links what's in
这个是唯一连接

1414
00:57:56,605 --> 00:57:57,971
your StoryBoard with your code.
你代码和 StoryBoard 的东西

1415
00:57:57,973 --> 00:58:00,674
The names of outlets, the names of methods,
outlet 的名字，method 的名字，

1416
00:58:00,676 --> 00:58:01,974
the action methods.
action 的名字

1417
00:58:01,976 --> 00:58:04,610
The name of your UIViewControllers.
你的 UIViewController 的名字，

1418
00:58:04,612 --> 00:58:06,412
The name of your UIViews.
你的 UIView 的名字

1419
00:58:06,414 --> 00:58:07,612
Okay? It's all by name.
好吧？所有的都是和名字有关

1420
00:58:07,614 --> 00:58:09,881
So you have to go to the Identity Inspector here and
所以你需要到 Identity Inspector 这里，然后

1421
00:58:09,883 --> 00:58:12,050
make sure that name matches up.
保证你的名字对得上号

1422
00:58:12,052 --> 00:58:13,835
So now, you can see
现在你可以看到，

1423
00:58:13,836 --> 00:58:15,619
this says that it's a HappinessViewController.
这里说它是一个 HappinessViewController

1424
00:58:15,621 --> 00:58:20,240
So that's making me happy. Okay.
这让我很快乐

1426
00:58:20,241 --> 00:58:22,758
Now, we want to put our custom view in here, okay?
现在我们想把我们自定义的 View 放进去，

1427
00:58:22,761 --> 00:58:26,329
So how do I add a custom view to my UI?
那我怎么把这个自定义的 View 放进去呢？

1428
00:58:26,331 --> 00:58:29,231
And the answer is, I go into the Object Pallet.
答案就是，我又一次选择 Object Pallet

1429
00:58:29,233 --> 00:58:30,766
It's all the way at the bottom,
一直滚下去，

1430
00:58:30,768 --> 00:58:32,134
near the bottom somewhere.
知道就快到底部的时候

1431
00:58:32,136 --> 00:58:32,901
Where is that thing?
在哪里呢？

1432
00:58:32,903 --> 00:58:33,801
There it is.
在这里

1433
00:58:33,803 --> 00:58:35,870
You can drag out a generic view.
你可以拖出一个普通的 View

1434
00:58:35,872 --> 00:58:37,705
So this is just a UIView.
这其实是一个 UIView

1435
00:58:37,707 --> 00:58:39,339
Now when I drag it out,
现在当我拖出来

1436
00:58:39,341 --> 00:58:43,343
I'm gonna put it right here with the dashed blue lines.
我将把它放在这些虚蓝线这里

1437
00:58:43,345 --> 00:58:46,279
'Kay, because we know that that's a good thing to do.
因为我们知道这么做总是好的

1438
00:58:46,281 --> 00:58:50,416
And I want to set up the AutoLayout so
我想要设置 AutoLayout，因此

1439
00:58:50,418 --> 00:58:56,054
that this view always fully fills my scene here.
这个 View 将填满我的整个画面

1440
00:58:56,056 --> 00:58:58,489
Okay? Now I could Control drag to
现在，我可以按住 Control 拖动到边缘，

1441
00:58:58,491 --> 00:59:02,560
the edges like I did before, but since this is already
就像我之前做的那样，但是现在这已经

1442
00:59:02,562 --> 00:59:06,630
perfectly where I want it, and I use the blue lines, I
很完美了，所以我用这些蓝线

1443
00:59:06,632 --> 00:59:12,302
can go down here and use Reset to Suggested Constraints. 'Kay?
我可以在下面用这个 Reset to Suggested Constraints

1445
00:59:12,303 --> 00:59:13,602
Now, I'm only showing you dribs and drabs of AutoLayout.
现在我只是一点点地向你们展示 AutoLayout

1446
00:59:13,605 --> 00:59:16,105
I wasn't gonna talk all about Auto Layout today, but
我不会在今天讲 AutoLayout 的，但是

1447
00:59:16,107 --> 00:59:17,439
we need to move on to this.
在这里我们需要这么做

1448
00:59:17,441 --> 00:59:19,941
But I will be having the lecture on AutoLayout,
我会专门有节课讲 AutoLayout，

1449
00:59:19,943 --> 00:59:21,409
probably week after next.
也许是下下周

1450
00:59:21,411 --> 00:59:23,745
In the meantime I'm just gonna show you little bits of it and
同时我会展示一点点，

1451
00:59:23,747 --> 00:59:25,730
you can explore.
让你们摸索一下

1452
00:59:25,731 --> 00:59:27,714
I'm never gonna ask you to do a ton of it in your homework.
我不会让你们在作业中做很多这个，

1453
00:59:27,717 --> 00:59:30,084
So this one I'm gonna Reset to Suggested Constraints, and
所以对于这个我将选 Reset to Suggested Constraints，

1454
00:59:30,086 --> 00:59:31,284
it added those Constraints.
然后它就添加了这些 Constraints（约束）

1455
00:59:31,286 --> 00:59:32,585
And I could go over here.
我可以点击这里

1456
00:59:32,587 --> 00:59:34,187
Let me make some more space here.
让我在这里腾出多一点空间

1457
00:59:34,189 --> 00:59:35,654
I could go look at them over here.
我可以在这里浏览到它们

1458
00:59:35,656 --> 00:59:37,523
You've all determined that.
你已经确定了这些

1459
00:59:37,525 --> 00:59:40,559
Another place you can see the Constraints of a view is
另一个能看到 View 的这些 Constraints 的地方是

1460
00:59:40,561 --> 00:59:42,193
here in the Size Inspector.
在这个 Size Inspector 这里

1461
00:59:42,195 --> 00:59:44,662
If you look towards the bottom of the Size Inspector-
如果你看 Size Inspector 的最底部，

1462
00:59:44,664 --> 00:59:46,163
Look, here's all the Constraints, see?
看，这里就是全部的 Constraints，看到么

1463
00:59:46,165 --> 00:59:48,165
Trailing, leading, top, bottom.
Trailing, leading, top, bottom.

1464
00:59:48,167 --> 00:59:50,634
It added all these because these are the Suggested
这里添加的全部都是刚刚添加的

1465
00:59:50,636 --> 00:59:55,822
constraints based on the dash blue lines that I used. Okay?
Suggested Constraints，基于刚刚我用的那些蓝色虚线

1467
00:59:55,823 --> 00:59:57,673
So, oftentimes if you put something in place perfectly
一般来说你把东西都放到刚刚好的位置，

1468
00:59:57,675 --> 00:59:58,874
with the blue lines,
放到有蓝线的位置，

1469
00:59:58,876 --> 01:00:01,443
you can use Reset to Suggested Constraints.
你就可以用 Reset to Suggested Constraints

1470
01:00:01,445 --> 01:00:04,979
We coulda done that with our display in our Calculator.
我们也可以在在我们的 Calculator 中的显示结果的那个地方使用

1471
01:00:04,981 --> 01:00:06,748
We couldn't do it with the buttons.
但是我们不能用在按钮上

1472
01:00:06,750 --> 01:00:09,116
Cuz it just wasn't lined up enough with other things, but
因为它并没有和其他的物体排列起来，但是

1473
01:00:09,118 --> 01:00:11,618
we could have done it with the display.
我们可以用于显示结果的那里

1474
01:00:11,620 --> 01:00:12,853
All right? So now we have this.
好的，现在我们有了这个

1475
01:00:12,855 --> 01:00:17,623
Now, this UIView, let's look at its Identity Inspector.
这个 UIView，我们看看它的 Identity Inspector

1476
01:00:17,625 --> 01:00:19,258
It's just a generic UIView.
它是个普通的 UIView

1477
01:00:19,260 --> 01:00:20,726
That's no good.
这并不好

1478
01:00:20,727 --> 01:00:22,193
We need a custom UIView sub-class.
我们需要一个自定义的 UIView 子类

1479
01:00:22,196 --> 01:00:23,161
So let's go do that.
我们来实现这个

1480
01:00:23,163 --> 01:00:24,996
File > New File.
选择 File > New File

1481
01:00:24,998 --> 01:00:26,665
Same thing,
一样的，

1482
01:00:26,666 --> 01:00:28,333
I'm gonna create a subclass of a Cocoa Touch Class.
我将创建 Cocoa Touch Class 的子类

1483
01:00:28,335 --> 01:00:30,801
This one's not gonna be a View Controller,
这次不是一个 View Controller，

1484
01:00:30,803 --> 01:00:32,202
it's gonna be a UIView.
而是一个 UIView

1485
01:00:32,204 --> 01:00:33,837
Okay? I'm gonna call it FaceView,
好的，我将叫它 FaceView，

1486
01:00:33,839 --> 01:00:35,238
cuz that's what it's gonna do.
因为它要做的就是，

1487
01:00:35,240 --> 01:00:38,041
It's gonna draw a face, okay?
显示出一张脸

1488
01:00:38,043 --> 01:00:40,776
Put it in the same place, put everything.
将它放在同一个地方，放所有文件的地方

1489
01:00:40,778 --> 01:00:42,845
Here's our, my FaceView right here.
这里是我们的 FaceView

1490
01:00:42,847 --> 01:00:44,413
We'll get back to that in a second.
我们一会再回来这里

1491
01:00:44,415 --> 01:00:45,780
In our StoryBoard,
在我们的 StoryBoard 中

1492
01:00:45,782 --> 01:00:49,517
we wanna make sure that we inspect our FaceView.
我们想确保我们能观察我们的 FaceView

1494
01:00:49,519 --> 01:00:51,718
Okay? And change its class to FaceView.
然后把它的类改成 FaceView

1495
01:00:51,721 --> 01:00:54,087
By the way, it can kinda get tricky sometimes,
顺带说一句，选择到一个你想要的东西，

1496
01:00:54,089 --> 01:00:55,655
picking the right thing.
有时候会比较困难

1497
01:00:55,657 --> 01:00:57,490
Like, sometimes you're picking the UIViewController,
比如说有时候你想选择 UIViewController，

1498
01:00:57,492 --> 01:00:58,691
sometimes you're picking the view.
但有时你会不小心选到 View

1499
01:00:58,693 --> 01:01:02,628
One kinda cool trick, Control + Shift.
有个酷炫的小技巧，就是按 Control + Shift

1500
01:01:02,630 --> 01:01:05,397
If you hold Control + Shift and click, then it
如果你按住 Control + Shift 然后点击，它会

1501
01:01:05,399 --> 01:01:09,367
lets you pick which thing you want, that's under the mouse.
在这个鼠标位置后面，有许多东西，它会让你选择其中一个

1502
01:01:09,369 --> 01:01:11,636
A very important little trick, Control + Shift.
所以，这个是一个很重要的小技巧，Control + Shift

1503
01:01:11,638 --> 01:01:13,804
So here I could pick the View Controller.
这里我可以选择 View Controller

1504
01:01:13,806 --> 01:01:15,539
Now I'm seeing the Identity Inspector of
现在我看到，Identity Inspector

1505
01:01:15,541 --> 01:01:16,473
the View Controller.
是我选择的那个 View Controller

1506
01:01:16,475 --> 01:01:18,041
Or I could go here and pick,
同样，我可以在这里选择

1507
01:01:18,043 --> 01:01:20,843
this is the view property in my View Controller.
这是我的 View Controller 中的 view 属性

1508
01:01:20,845 --> 01:01:21,977
The top level view.
最顶层的 view

1509
01:01:21,979 --> 01:01:24,380
This is my FaceView that I'm trying to create.
这是我想要创建的 FaceView

1510
01:01:24,382 --> 01:01:26,615
So I select this here, then I'm gonna go to
所以我选择这个，然后我来到

1511
01:01:26,617 --> 01:01:28,750
the Identity Inspector again, up here.
上面的 Identity Inspector

1512
01:01:28,752 --> 01:01:32,887
I'm gonna change this to be a FaceView. Okay?
并将其改成 FaceView

1514
01:01:32,889 --> 01:01:35,189
So now this thing is a FaceView, and so
那么现在这个 view 就是 FaceView 了

1515
01:01:35,191 --> 01:01:37,524
when it's time for this thing to draw,
当有需要绘制的时候

1516
01:01:37,526 --> 01:01:40,727
it's gonna call the drawRect of the FaceView class.
这将会调用 FaceView 类里的 drawRect 方法

1517
01:01:40,729 --> 01:01:43,096
So let's go take a look at the FaceView class.
所以现在我们来看看这个 FaceView

1518
01:01:43,098 --> 01:01:44,630
Here it is.
这里就是 FaceView 的代码

1519
01:01:44,632 --> 01:01:48,100
And here is drawRect.
这里是 drawRect 方法

1520
01:01:48,102 --> 01:01:50,602
Now, it's commented out by default.
现在，它默认是被注释的

1521
01:01:50,604 --> 01:01:52,303
Why is it commented out by default?
为什么默认被注释掉呢？

1522
01:01:52,305 --> 01:01:57,308
Well because having a drawRect costs system resources.
因为调用 drawRect 会消耗系统资源

1523
01:01:57,310 --> 01:01:59,677
It thinks it has to draw this thing.
系统认为需要重绘这个东西

1524
01:01:59,678 --> 01:02:02,045
So you only wanna have a drawRect if you actually draw,
所以当你确实需要手动绘制的时候，你才需要实现 drawRect 方法

1525
01:02:02,047 --> 01:02:03,279
in your drawRect.

1526
01:02:03,281 --> 01:02:06,149
Don't have it just sitting there uncommented out,
当你并不需要手动绘制的时候

1527
01:02:06,151 --> 01:02:08,050
if you're not actually using it.
别让 drawRect 方法取消注释但不做任何操作

1528
01:02:08,052 --> 01:02:10,386
All right, so, how am I gonna draw this face?
好的，我怎么画这个脸出来呢？

1529
01:02:10,388 --> 01:02:13,622
Let's start by drawing the outline of the head.
我们从画头的轮廓开始吧

1530
01:02:13,624 --> 01:02:16,074
Just a round circle. Okay?
一个圆圈

1532
01:02:16,075 --> 01:02:17,158
Cuz that's pretty simple to draw.
因为这很简单

1533
01:02:17,160 --> 01:02:20,695
And how am I gonna do that?
我该怎么做？

1534
01:02:20,697 --> 01:02:24,164
Let's start by creating a BezierPath.
我们开始创建一个 UIBezierPath 吧

1535
01:02:24,166 --> 01:02:29,636
I'll call it facePath which is, BezierPath.
我叫这个为 facePath，是一个 UIBezierPath 对象

1536
01:02:29,638 --> 01:02:31,188
And let's look at
让我们看看

1537
01:02:31,189 --> 01:02:32,739
all the different kinds of BezierPaths we can make.
我们能用 UIBezierPath 绘制的所有东西吧

1538
01:02:32,741 --> 01:02:34,257
Ovals.
椭圆形

1539
01:02:34,258 --> 01:02:35,774
We could use this one, ovalInRect, okay?
我们可以用 ovalInRect 这个方法

1540
01:02:35,777 --> 01:02:36,809
That's a pretty good one.
这是个不错的选择

1541
01:02:36,811 --> 01:02:38,977
I'm actually gonna use this one,
事实上，我要用这个

1542
01:02:38,979 --> 01:02:42,447
arcCenter cuz I wanna show you a really bad error message
arcCenter，因为我想向你们展示一些你将会在 Swift 中遇到的错误信息

1543
01:02:42,449 --> 01:02:45,650
you're gonna get in Swift that I want you to avoid.
我希望你们能够避免这些地方

1544
01:02:45,652 --> 01:02:48,019
So I'm gonna use this one which lets you create an arc,
所以我需要这个，让你创建一个弧

1545
01:02:48,021 --> 01:02:50,254
and I'm just gonna have my arc go all the way around.
然后我想让这个弧绕成一个圆

1546
01:02:50,256 --> 01:02:52,089
Okay? From zero all the way around.
从 0 度到 360 度

1547
01:02:52,091 --> 01:02:54,190
So, it wants to know the center.
它需要知道中心点在哪里

1548
01:02:54,192 --> 01:02:56,626
So I'm gonna have to have my faces center somehow.
我假设这里有一个 faceCenter 是这个圆的中心点

1549
01:02:56,628 --> 01:02:58,094
We'll define that in a second.
我们稍后会定义它

1550
01:02:58,096 --> 01:03:00,229
It also wants to know the radius, so
同样，这个方法需要知道半径是多少

1551
01:03:00,231 --> 01:03:02,731
I have to have my faces radius in a second.
所以我同样假设这里有一个 faceRadius 是这个圆的半径

1552
01:03:02,733 --> 01:03:04,332
We'll do that.
同样我们稍后定义它

1553
01:03:04,334 --> 01:03:07,602
It wants to know the start angle, to draw this arc.
另外，它还需要知道画这个弧度的起始角度

1554
01:03:07,604 --> 01:03:09,003
Okay? So
这里

1555
01:03:09,004 --> 01:03:10,403
I'm gonna start at angle zero.
我将从 0 度开始

1556
01:03:10,406 --> 01:03:12,339
The angle's in radians.
半径是用弧度来计算的

1557
01:03:12,341 --> 01:03:15,542
So I wanna go around to 2pi.
所以我希望它能从 0 度画到 2pi

1558
01:03:15,544 --> 01:03:17,444
Going, I'm gonna draw an arc from zero,
继续，我将从 0 度开始画这个弧

1559
01:03:17,446 --> 01:03:19,045
all the way around to 2pi radians.
绕一圈直到 2pi 的弧度

1560
01:03:19,047 --> 01:03:22,965
Hopefully everyone knows what radians are. Okay?
希望所有人都知道弧度是什么

1562
01:03:22,966 --> 01:03:24,482
So zero to 2pi that's good, and then clockwise or
所以，0 到 2pi，没问题了吧？，顺时针还是

1563
01:03:24,485 --> 01:03:25,935
counter clockwise,
逆时针

1564
01:03:25,936 --> 01:03:27,386
I don't care cuz I'm going all the way around.
我不在乎是顺还是逆，因为我画的是一个整圆

1565
01:03:27,388 --> 01:03:28,953
So I'll just say clockwise true.
所以我选择顺时针，clockwise: true

1566
01:03:28,955 --> 01:03:31,823
Now, when I do this, well first let's do
现在，当我这么做，我们先定义

1567
01:03:31,825 --> 01:03:34,458
our faceCenter and faceRadius here.
我们的 faceCenter 和 faceRadius 吧

1568
01:03:34,460 --> 01:03:40,630
So I'm gonna make actually computed properties for those.
事实上我将会让这俩变成 computed properties

1569
01:03:40,632 --> 01:03:43,600
So the faceCenter is a CGPoint.
faceCenter 是一个 CGPoint

1570
01:03:43,602 --> 01:03:47,970
And really, it would be cool, yeah, I could do get and set.
作为一个 computed properties，我可以编写 get 和 set 方法

1571
01:03:47,972 --> 01:03:51,240
It's gonna be Get Only. Okay?
但在这里我只需要 get

1573
01:03:51,241 --> 01:03:52,574
I'm not gonna allow me to set my faceCenter,
我不允许用户来设置 faceCenter 的值

1574
01:03:52,576 --> 01:03:54,209
I'm almost going to calculate it.
get 方法大部分工作就是计算

1575
01:03:54,211 --> 01:03:56,644
I could make it settable, actually too, but
事实上我也可以让 faceCenter 能够被赋值，但

1576
01:03:56,646 --> 01:03:59,080
I'm gonna make it so it's calculated only.
这里，我只让它能够计算

1577
01:03:59,082 --> 01:04:00,681
When you do calculated only,
当你只用做计算时

1578
01:04:00,683 --> 01:04:03,050
you actually don't need this part.
你就不需要编写 get {...} 这部分

1579
01:04:03,052 --> 01:04:03,683
This get.
这里的 get

1580
01:04:03,685 --> 01:04:04,851
You can take that out.
你可以把它删去

1581
01:04:04,853 --> 01:04:06,352
And if it's returned Only.
而且，如果它只是返回一个数值

1582
01:04:06,354 --> 01:04:08,253
So I'll say return.
我会写 return

1583
01:04:08,255 --> 01:04:11,023
Now I, you might be saying oh I'm gonna return center,
现在你也许会写 return center

1584
01:04:11,025 --> 01:04:12,257
let's put the face in the center.
把我们的 FaveView 放在 center 上吧

1585
01:04:12,259 --> 01:04:15,660
Did everyone understand why this is very bad?
大家都明白这里为什么错了吗？

1586
01:04:15,662 --> 01:04:17,528
All right, cuz center is not in my coordinate system.
因为这个 center 并不在我的坐标系中

1587
01:04:17,530 --> 01:04:19,029
It's in my superview's coordinate system.
它在我的 superview 的坐标系中

1588
01:04:19,031 --> 01:04:23,967
Luckily, I can convert a point from my superview's coordinate
不过幸运地，我可以把这个点从 superview 的坐标系转换到

1589
01:04:23,969 --> 01:04:29,138
system using this nice method, convertPoint(fromView:).
我的坐标系中，用一个很好用的方法叫 convertPoint(fromView:)

1590
01:04:29,140 --> 01:04:34,876
So I'm gonna convert center from my superview. Okay?
所以我从 superview 转换 center

1592
01:04:34,877 --> 01:04:36,376
That's gonna put my face right in the center,
这将会让我的笑脸放在正中心

1593
01:04:36,379 --> 01:04:39,680
cuz I've converted that center from my superview's coordinate
因为我从 superview 的坐标系转换过来

1594
01:04:39,682 --> 01:04:41,381
system to mine. Okay?
成为我的坐标系的 center

1596
01:04:41,383 --> 01:04:43,083
So that's faceCenter.
那么这个就是 faceCenter 了

1597
01:04:43,085 --> 01:04:45,151
Let's also do faceRadius.
接着来定义 faceRadius

1598
01:04:45,153 --> 01:04:46,786
So for the faceRadius,
那么对于这个 faceRadius

1599
01:04:46,788 --> 01:04:50,990
I'm gonna have it be as big as it can be. Okay?
我将希望它尽可能的大

1601
01:04:50,991 --> 01:04:52,491
So faceRadius is gonna be a CGFloat to all of
faceRadius 会是 CGFloat 类型的

1602
01:04:52,493 --> 01:04:55,493
our drawing stuff is Float, and I'm gonna return as big as
所有的绘画元素都是 Float 类型的，在它不会被截断的情况下

1603
01:04:55,495 --> 01:04:57,261
it can be without getting cut off.
我会让它尽可能大

1604
01:04:57,263 --> 01:04:59,563
So it's gonna be the minimum of my width or height.
所以，让它成为宽和高中较小的那一个

1605
01:04:59,565 --> 01:05:03,934
So I'm gonna say, min of my bounds.
这里我输入 min(bounds

1606
01:05:03,936 --> 01:05:06,203
Sorry.
抱歉

1607
01:05:06,204 --> 01:05:08,471
bounds.size.width, or my bounds.size.height.
min(bounds.size.width, bounds.size.height)

1608
01:05:08,473 --> 01:05:10,306
Whichever is less than that.
哪个短用哪个

1609
01:05:10,307 --> 01:05:12,140
Min is just a nice little function in Swift.
Swift 中的 min 是一个不错的小函数

1610
01:05:12,143 --> 01:05:15,077
And I'm gonna divide by two because this is a radius,
这里把它除以 2，因为这是半径

1611
01:05:15,079 --> 01:05:16,612
not diameter of my face.
不是直径

1612
01:05:16,614 --> 01:05:17,946
This is the radius.
这就是 faceRadius

1613
01:05:17,948 --> 01:05:20,982
So now I have my center facing radius, but
现在我有了半径和中心

1614
01:05:20,984 --> 01:05:22,984
I still have an error here.
但是这里还是有个错误

1615
01:05:22,986 --> 01:05:24,669
Look at this error.
来看看这个错误

1616
01:05:24,670 --> 01:05:26,353
Even though I did my center, I did my radius.
即使我算好了中心位置，算好了半径

1617
01:05:26,356 --> 01:05:27,554
I still have an error.
这里还是有错误

1618
01:05:27,556 --> 01:05:28,955
What is the problem?
到底是什么问题？

1619
01:05:28,957 --> 01:05:31,891
Oh, "Extra argument 'radius' in call".
噢，"Extra argument 'radius' in call"

1620
01:05:31,893 --> 01:05:33,760
Huh.

1621
01:05:33,762 --> 01:05:34,944
That's weird.
这很奇怪

1622
01:05:34,945 --> 01:05:36,127
I didn't see any extra argument.
我没看到额外的参数

1623
01:05:36,130 --> 01:05:37,329
What the heck is that about?
到底出什么错了？

1624
01:05:37,331 --> 01:05:39,131
Okay.

1625
01:05:39,132 --> 01:05:40,932
You could waste a half an hour looking for this, okay?
你可能会花半个小时找错误

1626
01:05:40,934 --> 01:05:42,250
I was thinking, oh,
你可能会想

1627
01:05:42,251 --> 01:05:43,567
radius, there's nothing wrong with the radius.
radius，radius 这里也没什么问题啊

1628
01:05:43,570 --> 01:05:45,687
It's right.
是的

1629
01:05:45,688 --> 01:05:47,805
The problem for this has nothing to do with the radius.
radius 跟这个问题一点关系都没有

1630
01:05:47,807 --> 01:05:50,708
The problem is this.
问题在这，2*M_PI

1631
01:05:50,710 --> 01:05:52,410
Okay?
明白了吗？

1632
01:05:52,411 --> 01:05:54,111
So this is an error you get from switching occasionally,
这个错误你们可能会偶尔遇到

1633
01:05:54,113 --> 01:05:56,813
I'm sure they'll fix all these errors, but occasionally,
我确定 Apple 会修复好这些错误

1634
01:05:56,815 --> 01:05:59,416
you get this very misleading error, and this is one.
但是偶尔还是会获得这些误导你的错误，这就是一个

1635
01:05:59,418 --> 01:06:00,817
The problem is that this-
问题在于

1636
01:06:00,819 --> 01:06:01,784
What type is this?
它的类型是什么？

1637
01:06:05,022 --> 01:06:06,021
It's a Double.
它是一个 Double

1638
01:06:06,023 --> 01:06:07,489
Yeah.
是的

1639
01:06:07,490 --> 01:06:08,956
And what type do we draw with?
但是我们绘画用什么类型的？

1640
01:06:08,959 --> 01:06:10,224
CGFloat.
CGFloat

1641
01:06:10,226 --> 01:06:14,194
So this problem is just that I need to cast this to
所以把它转型成 CGfloat，这个问题就可以

1642
01:06:14,196 --> 01:06:15,195
a CGFloat.
解决了

1643
01:06:15,197 --> 01:06:16,908
Okay?
明白了吗？

1644
01:06:16,909 --> 01:06:18,620
That's gonna make this error go away.
这个错误就会消失了

1645
01:06:18,621 --> 01:06:20,332
It had nothing to do with radius whatsoever there.
跟 radius 一点关系都没有

1646
01:06:20,335 --> 01:06:22,168
Okay?

1647
01:06:22,169 --> 01:06:24,002
So, best warning, watch out for that.
这就是我给你们的提醒，以后要注意点

1648
01:06:24,005 --> 01:06:26,605
All right, so I have my nice facePath here.
我已经得到了 facePath

1649
01:06:26,607 --> 01:06:30,476
Maybe I wanna set my facePath's lineWidth.
在这里设置一下 facePath 的 lineWidth（线宽）

1650
01:06:30,478 --> 01:06:34,246
Something like three, something like that.
设置成 3 吧

1651
01:06:34,248 --> 01:06:36,181
In fact, maybe I even want lineWidth to
我想把 lineWidth 变成 FaceView 中

1652
01:06:36,183 --> 01:06:42,019
be something that's configurable in my FaceView.
可以设置的一个属性

1653
01:06:42,021 --> 01:06:43,253
So it's a CGFloat.
类型是 CGFloat

1654
01:06:43,255 --> 01:06:45,222
And we'll set it to default of three.
我们把它的默认设置为 3

1655
01:06:45,224 --> 01:06:46,790
One thing that's interesting and
一个很有趣的事是

1656
01:06:46,792 --> 01:06:48,891
then we'll set this down here to lineWidth.
我先把这里设置成 lineWidth

1657
01:06:48,893 --> 01:06:51,794
One thing that's interesting about this is any time
一个有趣的事情是，无论何时 lineWidth 被改变了

1658
01:06:51,796 --> 01:06:54,997
someone changes my lineWidth, I need to redraw myself.
我都需要把这个 view 重新绘制一遍

1659
01:06:54,999 --> 01:06:56,565
All right?
明白了吗？

1660
01:06:56,567 --> 01:06:58,133
So how can I make that happen?
我怎么做才能实现呢？

1661
01:06:58,135 --> 01:07:01,502
Well, I can use Property Observer.
我可以使用 Property Observer

1662
01:07:01,504 --> 01:07:02,937
Okay?

1663
01:07:02,938 --> 01:07:04,371
Anytime someone sets this,
无论什么时候，有人改变了它

1664
01:07:04,373 --> 01:07:08,108
I'm gonna call setNeedsDisplay on myself.
我就会在向自身调用 setNeedsDisplay

1665
01:07:08,110 --> 01:07:09,709
Okay?
明白了吗？

1666
01:07:09,711 --> 01:07:11,127
Bam.

1667
01:07:11,128 --> 01:07:12,544
I'm in it redrawn by the system.
系统就会帮你重新绘制视图

1668
01:07:12,547 --> 01:07:13,879
Okay? So anytime you have
如果在你的 view 中有一个

1669
01:07:13,881 --> 01:07:16,815
a property in your, in a view that changes how you would be
property 在改变的时候需要被重新绘制

1670
01:07:16,817 --> 01:07:19,284
drawn, just put a little Property Observer into
只要在 Property Observer 里调用

1671
01:07:19,286 --> 01:07:20,952
the setNeedsDisplay after it.
setNeedsDisplay 就可以了

1672
01:07:20,954 --> 01:07:23,354
And it'll get you automatically redrawn.
它就会帮你重新绘制

1673
01:07:23,356 --> 01:07:25,189
Maybe I'll have another property here,
在这里我还想添加一个

1674
01:07:25,191 --> 01:07:26,490
which is the color I wanna be.
颜色的 property

1675
01:07:26,492 --> 01:07:29,626
UIColor, we'll set the default here to be
类型是 UIColor，默认设置成

1676
01:07:29,628 --> 01:07:31,461
blueColor for example.
蓝色

1677
01:07:31,463 --> 01:07:33,329
But I want the exact same thing here.
但我也想跟这里一样

1678
01:07:33,331 --> 01:07:34,029
Okay?

1679
01:07:34,031 --> 01:07:35,330
Someone sets it.
有人改变了它

1680
01:07:35,332 --> 01:07:36,631
I want it redrawn.
视图就会被重新绘制

1681
01:07:36,633 --> 01:07:39,167
And so let's go ahead and set our color.
现在设置一下颜色

1682
01:07:39,169 --> 01:07:42,003
Now I'm gonna do both my set, I could do setFill and
我既可以做 setFill 又可以做 setStroke

1683
01:07:42,005 --> 01:07:44,638
setStroke colors, but I'm just gonna do set,
我两者都想做，但这里，只要 set 就可以了

1684
01:07:44,640 --> 01:07:46,773
which sets both my fill and my stroke.
这样填充和笔画的颜色都会被设置

1685
01:07:46,775 --> 01:07:49,976
I'm not gonna be filling so it doesn't matter, but set to
因为这里不会被填充，所以调用 set 也没问题

1686
01:07:49,978 --> 01:07:53,146
both, and then how do I draw this BezierPath right here?
然后呢？我怎么绘制 BezierPath？

1687
01:07:53,148 --> 01:07:56,716
I just say, facePath.stroke.
facePath.stroke 就可以了

1688
01:07:56,718 --> 01:08:01,319
And that's gonna draw, okay?
这样就可以绘制了

1689
01:08:01,321 --> 01:08:04,456
So let's go take a look at this.
我们运行一下程序

1690
01:08:04,458 --> 01:08:11,395
Okay.

1691
01:08:11,397 --> 01:08:13,397
So, it comes up, it's blank.
运行起来了，它是空的

1692
01:08:13,399 --> 01:08:15,866
And not only is it blank, it's got some error down here.
不仅仅是空白的，这里还有一些错误信息

1693
01:08:15,868 --> 01:08:17,918
What does it say? It says,
它说

1694
01:08:17,919 --> 01:08:19,969
failed to instantiate the default View Controller.
failed to instantiate the default View Controller（初始化默认 View Controller 失败）

1695
01:08:19,971 --> 01:08:21,738
Okay? Well that means that in my
这表明

1696
01:08:21,740 --> 01:08:27,009
StoryBoard, there is no scene that's specified,
在 StoryBoard 中，没有指定

1697
01:08:27,011 --> 01:08:29,444
as the scene to start in.
开始场景

1698
01:08:29,446 --> 01:08:31,079
Okay? It has no starting scene.
没有开始场景

1699
01:08:31,081 --> 01:08:33,848
The starting scene always has a little arrow pointing to it.
开始场景总是有一个指向它的小箭头

1700
01:08:33,850 --> 01:08:34,983
Right here,
在这里

1701
01:08:34,984 --> 01:08:36,117
you've probably seen in in your Calculator right?
你们可能在 Calculator 中已经见过了

1702
01:08:36,119 --> 01:08:38,419
A little arrow that says this is the place to come in
当你运行程序时

1703
01:08:38,421 --> 01:08:39,720
when you start this app.
一个代表程序入口点的小箭头

1704
01:08:39,722 --> 01:08:42,322
You can set that arrow with the Inspector the regular
你可以在选中的 View Controller 的

1705
01:08:42,324 --> 01:08:44,524
Attributes Inspector by selecting your
Attributes Inspector 里

1706
01:08:44,526 --> 01:08:47,693
View Controller that you wanna be the one that comes in.
设置它为入口场景

1707
01:08:47,695 --> 01:08:48,894
And click. This little button here is
点击这里的小按钮

1708
01:08:48,896 --> 01:08:49,828
Initial View Controller.
Is Initial View Controller

1709
01:08:49,830 --> 01:08:51,129
You see that arrow appear?
看到剪头出现了吗？

1710
01:08:51,131 --> 01:08:52,997
You can also pick this arrow up and
你也可以把这个剪头选中

1711
01:08:52,999 --> 01:08:55,032
move it to another View Controller.
把它移动到另一个 View Controller 里

1712
01:08:55,034 --> 01:08:56,767
Okay?

1713
01:08:56,769 --> 01:08:59,269
So now we have a thing, oh all right.
好了

1714
01:08:59,271 --> 01:09:01,154
So we've got our face.
脸已经出现了

1715
01:09:01,155 --> 01:09:03,038
Now, one thing I don't like about this face is it goes all
现在我对这个脸不满意的地方就是

1716
01:09:03,041 --> 01:09:04,407
the way to the edges.
它太靠近边缘了

1717
01:09:04,409 --> 01:09:06,675
I want it to actually be 90% of the edges.
我想让它占据整个长度的 90%

1718
01:09:08,178 --> 01:09:09,544
Okay? Another thing I
另一件

1719
01:09:09,546 --> 01:09:10,712
don't like is this.
我不满意的事情是

1720
01:09:10,714 --> 01:09:12,113
Ugh, okay?
额

1721
01:09:12,115 --> 01:09:15,982
So my face is gonna be distorted every time I rotate.
每一次我旋转屏幕，脸都会被破坏

1722
01:09:15,984 --> 01:09:17,601
Why is that?
这是怎么回事儿？

1723
01:09:17,602 --> 01:09:19,219
That's this stretching thing I was telling you about.
这就是我之前告诉你们的拉伸的情况

1724
01:09:19,221 --> 01:09:22,155
We want our drawRect to be called again when we
我们希望每一个获得新的边界时（就像旋转屏幕）

1725
01:09:22,157 --> 01:09:24,523
have a new bounds like that.
drawRect 都会被再一次调用

1726
01:09:24,525 --> 01:09:26,492
So let's fix both of those things.
现在我们一起把它们处理好

1727
01:09:26,494 --> 01:09:29,795
We can fix that content mode redraw by selecting our view,
修改 Mode （重绘模式）的方法是：选中 view

1728
01:09:29,797 --> 01:09:31,596
going to the inspector up here,
去到 Inspector

1729
01:09:31,598 --> 01:09:33,431
the Attributes Inspector, and
Attributes Inspector

1730
01:09:33,433 --> 01:09:35,199
the very first one is the mode.
第一个就是 Mode

1731
01:09:35,201 --> 01:09:37,835
And you can see the default was scale to fill.
默认的是 Scale To Fill (拉伸以填充)

1732
01:09:37,837 --> 01:09:38,835
We want Redraw.
我们想要 Redraw (重绘)

1733
01:09:39,905 --> 01:09:41,170
Okay? So I'm gonna pick Redraw.
所以我选择 Redraw

1734
01:09:41,172 --> 01:09:42,738
So that'll fix that.
这样就修改好了

1735
01:09:42,740 --> 01:09:49,711
And as far as the 90%, I'm going to fix that in here,
至于 90%，我在这里修改

1736
01:09:49,713 --> 01:09:55,683
by having the, my face radius be times 90%.
把 faceRadius 再乘以 90%

1737
01:09:55,685 --> 01:09:58,319
But really, I'd like this to be settable too.
但是我也想让它成为一个可以被设置的

1738
01:09:58,321 --> 01:10:02,456
So I'm gonna have var scale, CGFloat.
添加一个变量 scale，类型是 CGFloat

1739
01:10:03,425 --> 01:10:05,358
Okay. And we'll start this out at
默认设置为

1740
01:10:05,360 --> 01:10:05,958
90%.

1741
01:10:05,960 --> 01:10:07,393
So I want that, and
我想让它

1742
01:10:07,395 --> 01:10:11,963
this one also, if I change, I want it to change.
在更改以后也重绘视图

1743
01:10:11,965 --> 01:10:13,231
Okay?

1744
01:10:13,232 --> 01:10:14,498
So now let's go try that.
运行一下程序

1745
01:10:14,501 --> 01:10:15,132
See what happens.
看看发生了什么

1746
01:10:15,134 --> 01:10:16,567
Okay? We got our 90%.
90% 已经实现了

1747
01:10:16,569 --> 01:10:18,135
That's good.
还不错

1748
01:10:18,136 --> 01:10:19,702
And when I rotate, it doesn't stretch it.
当我旋转屏幕时，也没有拉伸

1749
01:10:20,672 --> 01:10:22,138
Okay? And it's using the minimum of
它使用了宽度和高度中

1750
01:10:22,140 --> 01:10:23,072
the width or height.
较小的那个

1751
01:10:23,074 --> 01:10:24,006
Okay?

1752
01:10:24,008 --> 01:10:24,906
So that's good.
还不错

1753
01:10:24,908 --> 01:10:26,074
That's going good.
越来越好了哈

1754
01:10:26,076 --> 01:10:29,444
Now we wanna draw the eyes and the mouth, and
现在开始绘制眼睛和嘴巴

1755
01:10:29,446 --> 01:10:31,712
cuz time is running out here,
时间已经不多了

1756
01:10:31,714 --> 01:10:35,249
I'm actually gonna type those in super fast.
我将会用超快的速度输入

1757
01:10:35,251 --> 01:10:38,752
I posted for those of you who are trying to keep along here,
我会贴给你们这些源代码，所以

1758
01:10:38,754 --> 01:10:40,687
which is probably impossible.
就不要尝试手动输入了

1759
01:10:40,689 --> 01:10:44,390
To do that though, I need some constants.
为了实现这些，我需要一些常量

1760
01:10:44,392 --> 01:10:47,560
And this how we do constants in Swift.
在 Swift 中我们这样定义常量

1761
01:10:47,562 --> 01:10:49,461
We create structs.
创建 struct

1762
01:10:49,463 --> 01:10:52,330
Okay? And then use class, or
使用 class 或者

1763
01:10:52,332 --> 01:10:55,500
in this case, static lets.
在这里使用 static let 修饰

1764
01:10:55,502 --> 01:10:56,868
Okay? So this is gonna be
所以这个常量就是

1765
01:10:56,870 --> 01:11:00,071
a constant called Scaling.FaceRadiustoEyeRadius.
Scaling.FaceRadiustoEyeRadius

1766
01:11:00,073 --> 01:11:01,956
Okay. And

1767
01:11:01,957 --> 01:11:03,840
then I'm going to have a function here, that I'm
这里有个函数叫做 bezierPathForEye

1768
01:11:03,843 --> 01:11:07,911
gonna type in really, really fast, called bezierPathForEye.
同样我这里用了 Code Snippet

1769
01:11:07,913 --> 01:11:11,548
And it's just gonna return a BezierPath that draws an eye.
它会返回一个绘制一只眼睛的 BezierPath 对象

1770
01:11:11,550 --> 01:11:13,149
Either the left eye or the right eye.
左眼或者右眼

1771
01:11:13,151 --> 01:11:14,283
This says which one.
参数用来确定是哪一只眼睛

1772
01:11:14,285 --> 01:11:16,051
Okay? So it returns a BezierPath.
它返回了一个 BezierPath

1773
01:11:16,053 --> 01:11:18,804
Okay?

1774
01:11:18,805 --> 01:11:21,556
Then I'm gonna have another one, which is BezierSmile.
这里还会有一个函数，BezierSmile

1775
01:11:21,558 --> 01:11:23,124
We're gonna type that in real fast.
再一次使用 Code Snippet

1776
01:11:23,126 --> 01:11:24,158
Okay?
没问题吧？

1777
01:11:24,160 --> 01:11:26,060
So here is BeizerPath for smile.
这就是笑容的 BeizerPath

1778
01:11:26,062 --> 01:11:27,794
And what this is gonna do,
这个函数会

1779
01:11:27,796 --> 01:11:31,331
it's gonna take a fractionOfMaximumSmile.
把 fractionOfMaximumSmile 作为参数

1780
01:11:31,333 --> 01:11:33,800
So one is full smile.
1 是最开心的笑容

1781
01:11:33,802 --> 01:11:35,835
Minus one is full frown.
-1 是最难过的

1782
01:11:35,837 --> 01:11:37,069
And everywhere in between.
其余的值都在 1 和 -1 之间

1783
01:11:37,071 --> 01:11:38,570
'Kay? So that's what this does.
这就是它做的事情

1784
01:11:38,572 --> 01:11:39,738
And it returns a BeizerPath.
返回一个 BeizerPath

1785
01:11:39,740 --> 01:11:42,440
So now here in my drawRect,
在 drawRect 函数中

1786
01:11:42,442 --> 01:11:46,477
I can say bezierPathForEye, left eye.
调用 bezierPathForEye，left 作为参数

1787
01:11:46,479 --> 01:11:47,611
I got the BezierPath.
我获得了 BezierPath

1788
01:11:47,613 --> 01:11:51,047
I'm just gonna immediately send it stroke.
我立即用它调用 stroke

1789
01:11:51,049 --> 01:11:52,949
Okay?

1790
01:11:52,950 --> 01:11:54,850
And then BezierPath for the right eye.
接着是右眼的 BezierPath

1791
01:11:54,852 --> 01:11:56,985
I'm gonna send it stroke.
给它发送 stroke 消息

1792
01:11:56,987 --> 01:11:59,087
So I'm just gonna stroke the left eye and the right eye.
现在绘制了左眼和右眼

1793
01:11:59,089 --> 01:12:00,338
Okay?

1794
01:12:00,339 --> 01:12:01,588
Then I'm gonna do the smiliness.
接着处理笑容

1795
01:12:01,591 --> 01:12:06,127
So, I'm going to let smiliness equal some value.
我在这里写 let smiliness =

1796
01:12:06,129 --> 01:12:08,429
Let's start it at 0.75.
从 0.75 开始吧

1797
01:12:08,431 --> 01:12:11,064
We're pretty, pretty happy to start.
这是一个很开心很开心的数值了

1798
01:12:11,066 --> 01:12:13,767
And then I'm going to create a bez,
接着，我用上面的这些给笑容

1799
01:12:13,769 --> 01:12:16,269
this BezierPath using this thing up here for
创建一个 BezierPath

1800
01:12:16,271 --> 01:12:19,005
a smile, which is bezierPathForSmile.
用这个函数 bezierPathForSmile

1801
01:12:19,007 --> 01:12:22,775
And we're gonna pass it the smiliness.
把 smiliness 传进去

1802
01:12:22,777 --> 01:12:25,810
And then I'm just going to stroke this smile path.
然后绘制这个笑容的线条

1803
01:12:27,881 --> 01:12:29,147
Okay?

1804
01:12:29,148 --> 01:12:30,414
And I hoped to have a little more time so
我很希望能有时间

1805
01:12:30,416 --> 01:12:32,449
I could have gone through this code, but
跟大家一起分析代码

1806
01:12:32,451 --> 01:12:34,985
it's a pretty straightforward code, really.
但是这些代码都很易懂

1807
01:12:34,987 --> 01:12:37,654
Here we're just using addCurveToPoint in
这里，我们在 BezierPath 里

1808
01:12:37,656 --> 01:12:38,788
our BezierPath.
调用 addCurveToPoint

1809
01:12:38,790 --> 01:12:41,724
To draw a curve, which is the curve of the mouth.
接着，我们绘制嘴部的曲线

1810
01:12:41,726 --> 01:12:43,793
And then here,
接着，这儿

1811
01:12:43,794 --> 01:12:45,861
we're just using BezierPath arcCenter again.
我们又调用了一次 BezierPath(arcCenter: ...)

1812
01:12:45,863 --> 01:12:46,495
Okay?

1813
01:12:46,497 --> 01:12:48,063
To create the circle.
为了绘制圆

1814
01:12:48,064 --> 01:12:49,630
The eyes are just circles, okay?
眼睛都是圆的

1815
01:12:49,633 --> 01:12:50,965
That's really all those two methods do.
这就是这两个方法做的事情

1816
01:12:50,967 --> 01:12:53,100
There's nothing really special about them.
没什么特别的

1817
01:12:53,102 --> 01:12:57,004
And what do I have error here, which is, oops.
这里有个错误

1818
01:12:57,006 --> 01:12:58,971
Dot.
点

1819
01:12:58,973 --> 01:13:00,172
Okay?

1820
01:13:00,174 --> 01:13:01,607
That's not it either.
不是点

1821
01:13:01,609 --> 01:13:04,176
SmilePath oh, equals, not that.
SmilePath 等于，

1822
01:13:04,178 --> 01:13:05,143
Equals.
等号

1823
01:13:05,145 --> 01:13:06,044
There we go.
这就对了

1824
01:13:06,046 --> 01:13:06,744
Okay?

1825
01:13:06,746 --> 01:13:08,078
Yes?
有问题吗？

1826
01:13:08,080 --> 01:13:09,479
So let's run this.
运行一下程序

1827
01:13:09,481 --> 01:13:11,414
Hopefully, we'll have a smiley face.
希望我们能有一张笑脸

1828
01:13:13,284 --> 01:13:14,049
There it is.
来了

1829
01:13:14,051 --> 01:13:15,017
He looks pretty happy.
他看起来很快乐

1830
01:13:15,019 --> 01:13:16,051
We can rotate him.
我们可以旋转屏幕

1831
01:13:16,053 --> 01:13:17,335
He's very happy.
他真的很快乐

1832
01:13:17,336 --> 01:13:18,618
Okay, let's make him a little sad.
来，我们让他难过一点

1833
01:13:18,621 --> 01:13:21,422
How about minus 0.5?
-0.5 怎么样？

1834
01:13:21,424 --> 01:13:22,389
Minus 0.5.
-0.5

1835
01:13:22,391 --> 01:13:24,424
Pretty, pretty sad.
非常非常难过

1836
01:13:27,929 --> 01:13:29,495
Aw.

1837
01:13:29,497 --> 01:13:31,764
Okay?
明白了吗？

1838
01:13:31,766 --> 01:13:33,466
Okay.
好的

1839
01:13:33,467 --> 01:13:35,167
So now we have this nice FaceView.
FaceView 已经完成了

1840
01:13:35,169 --> 01:13:38,603
What we're gonna do in our next lecture, is we're going
下一次课要讲的是

1841
01:13:38,605 --> 01:13:41,439
to add a gesture so we can make him happy or sad.
给这个程序添加手势，我们就可以让他一会儿开心一会儿难过

1842
01:13:41,441 --> 01:13:42,306
Happy or sad.
开心或者难过

1843
01:13:42,308 --> 01:13:43,908
Okay?

1844
01:13:43,909 --> 01:13:45,509
We're also gonna put a gesture in there, a pinch gesture so
我们也会加入 Pinch Gesture (缩放手势)

1845
01:13:45,511 --> 01:13:46,977
we can make them bigger or smaller.
我们就能把他变大或者变小

1846
01:13:46,979 --> 01:13:49,396
Okay?

1847
01:13:49,397 --> 01:13:51,814
Then we're going to actually add a whole another MVC and
接着我们会添加另一个完整的 MVC

1848
01:13:51,817 --> 01:13:55,718
make a much more powerful application that just uses
使用 FaceView 制作一个

1849
01:13:55,720 --> 01:13:58,421
the FaceView.
更强大的应用

1850
01:13:58,422 --> 01:14:01,123
The HappinessViewController as a view in another MVC.
把 HappinessViewController 用作另一个 MVC 的 view

1851
01:14:01,125 --> 01:14:02,413
Okay?

1852
01:14:02,414 --> 01:14:03,702
So now we're going to do multiple MVCs.
我们接下来就会处理多个 MVC 了

1853
01:14:03,703 --> 01:14:04,991
So that's what we're gonna be doing on Monday.
这就是下周一要完成的事情了
